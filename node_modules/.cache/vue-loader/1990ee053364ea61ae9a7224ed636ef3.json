{"remainingRequest":"D:\\project\\notebook\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!D:\\project\\notebook\\node_modules\\view-design\\src\\components\\table\\table.vue?vue&type=script&lang=js&","dependencies":[{"path":"D:\\project\\notebook\\node_modules\\view-design\\src\\components\\table\\table.vue","mtime":1586505627000},{"path":"D:\\project\\notebook\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\project\\notebook\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"D:\\project\\notebook\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\project\\notebook\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCiAgICBpbXBvcnQgdGFibGVIZWFkIGZyb20gJy4vdGFibGUtaGVhZC52dWUnOwogICAgaW1wb3J0IHRhYmxlQm9keSBmcm9tICcuL3RhYmxlLWJvZHkudnVlJzsKICAgIGltcG9ydCB0YWJsZVN1bW1hcnkgZnJvbSAnLi9zdW1tYXJ5LnZ1ZSc7CiAgICBpbXBvcnQgU3BpbiBmcm9tICcuLi9zcGluL3NwaW4udnVlJzsKICAgIGltcG9ydCB7IG9uZU9mLCBnZXRTdHlsZSwgZGVlcENvcHksIGdldFNjcm9sbEJhclNpemUgfSBmcm9tICcuLi8uLi91dGlscy9hc3Npc3QnOwogICAgaW1wb3J0IHsgb24sIG9mZiB9IGZyb20gJy4uLy4uL3V0aWxzL2RvbSc7CiAgICBpbXBvcnQgQ3N2IGZyb20gJy4uLy4uL3V0aWxzL2Nzdic7CiAgICBpbXBvcnQgRXhwb3J0Q3N2IGZyb20gJy4vZXhwb3J0LWNzdic7CiAgICBpbXBvcnQgTG9jYWxlIGZyb20gJy4uLy4uL21peGlucy9sb2NhbGUnOwogICAgaW1wb3J0IGVsZW1lbnRSZXNpemVEZXRlY3Rvck1ha2VyIGZyb20gJ2VsZW1lbnQtcmVzaXplLWRldGVjdG9yJzsKICAgIGltcG9ydCB7IGdldEFsbENvbHVtbnMsIGNvbnZlcnRUb1Jvd3MsIGNvbnZlcnRDb2x1bW5PcmRlciwgZ2V0UmFuZG9tU3RyIH0gZnJvbSAnLi91dGlsJzsKCiAgICBjb25zdCBwcmVmaXhDbHMgPSAnaXZ1LXRhYmxlJzsKCiAgICBsZXQgcm93S2V5ID0gMTsKICAgIGxldCBjb2x1bW5LZXkgPSAxOwoKICAgIGV4cG9ydCBkZWZhdWx0IHsKICAgICAgICBuYW1lOiAnVGFibGUnLAogICAgICAgIG1peGluczogWyBMb2NhbGUgXSwKICAgICAgICBjb21wb25lbnRzOiB7IHRhYmxlSGVhZCwgdGFibGVCb2R5LCB0YWJsZVN1bW1hcnksIFNwaW4gfSwKICAgICAgICBwcm92aWRlICgpIHsKICAgICAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgICAgIHRhYmxlUm9vdDogdGhpcwogICAgICAgICAgICB9OwogICAgICAgIH0sCiAgICAgICAgcHJvcHM6IHsKICAgICAgICAgICAgZGF0YTogewogICAgICAgICAgICAgICAgdHlwZTogQXJyYXksCiAgICAgICAgICAgICAgICBkZWZhdWx0ICgpIHsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGNvbHVtbnM6IHsKICAgICAgICAgICAgICAgIHR5cGU6IEFycmF5LAogICAgICAgICAgICAgICAgZGVmYXVsdCAoKSB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9LAogICAgICAgICAgICBzaXplOiB7CiAgICAgICAgICAgICAgICB2YWxpZGF0b3IgKHZhbHVlKSB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9uZU9mKHZhbHVlLCBbJ3NtYWxsJywgJ2xhcmdlJywgJ2RlZmF1bHQnXSk7CiAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgZGVmYXVsdCAoKSB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICF0aGlzLiRJVklFVyB8fCB0aGlzLiRJVklFVy5zaXplID09PSAnJyA/ICdkZWZhdWx0JyA6IHRoaXMuJElWSUVXLnNpemU7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHdpZHRoOiB7CiAgICAgICAgICAgICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGhlaWdodDogewogICAgICAgICAgICAgICAgdHlwZTogW051bWJlciwgU3RyaW5nXQogICAgICAgICAgICB9LAogICAgICAgICAgICAvLyAzLjQuMAogICAgICAgICAgICBtYXhIZWlnaHQ6IHsKICAgICAgICAgICAgICAgIHR5cGU6IFtOdW1iZXIsIFN0cmluZ10KICAgICAgICAgICAgfSwKICAgICAgICAgICAgc3RyaXBlOiB7CiAgICAgICAgICAgICAgICB0eXBlOiBCb29sZWFuLAogICAgICAgICAgICAgICAgZGVmYXVsdDogZmFsc2UKICAgICAgICAgICAgfSwKICAgICAgICAgICAgYm9yZGVyOiB7CiAgICAgICAgICAgICAgICB0eXBlOiBCb29sZWFuLAogICAgICAgICAgICAgICAgZGVmYXVsdDogZmFsc2UKICAgICAgICAgICAgfSwKICAgICAgICAgICAgc2hvd0hlYWRlcjogewogICAgICAgICAgICAgICAgdHlwZTogQm9vbGVhbiwKICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHRydWUKICAgICAgICAgICAgfSwKICAgICAgICAgICAgaGlnaGxpZ2h0Um93OiB7CiAgICAgICAgICAgICAgICB0eXBlOiBCb29sZWFuLAogICAgICAgICAgICAgICAgZGVmYXVsdDogZmFsc2UKICAgICAgICAgICAgfSwKICAgICAgICAgICAgcm93Q2xhc3NOYW1lOiB7CiAgICAgICAgICAgICAgICB0eXBlOiBGdW5jdGlvbiwKICAgICAgICAgICAgICAgIGRlZmF1bHQgKCkgewogICAgICAgICAgICAgICAgICAgIHJldHVybiAnJzsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSwKICAgICAgICAgICAgY29udGV4dDogewogICAgICAgICAgICAgICAgdHlwZTogT2JqZWN0CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIG5vRGF0YVRleHQ6IHsKICAgICAgICAgICAgICAgIHR5cGU6IFN0cmluZwogICAgICAgICAgICB9LAogICAgICAgICAgICBub0ZpbHRlcmVkRGF0YVRleHQ6IHsKICAgICAgICAgICAgICAgIHR5cGU6IFN0cmluZwogICAgICAgICAgICB9LAogICAgICAgICAgICBkaXNhYmxlZEhvdmVyOiB7CiAgICAgICAgICAgICAgICB0eXBlOiBCb29sZWFuCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGxvYWRpbmc6IHsKICAgICAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sCiAgICAgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZQogICAgICAgICAgICB9LAogICAgICAgICAgICBkcmFnZ2FibGU6IHsKICAgICAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sCiAgICAgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZQogICAgICAgICAgICB9LAogICAgICAgICAgICB0b29sdGlwVGhlbWU6IHsKICAgICAgICAgICAgICAgIHZhbGlkYXRvciAodmFsdWUpIHsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gb25lT2YodmFsdWUsIFsnZGFyaycsICdsaWdodCddKTsKICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICBkZWZhdWx0OiAnZGFyaycKICAgICAgICAgICAgfSwKICAgICAgICAgICAgLy8gIzUzODAg5byA5ZCv5ZCO77yMOmtleSDlvLrliLbmm7TmlrDvvIzlkKbliJnkvb/nlKggaW5kZXgKICAgICAgICAgICAgLy8gNC4xIOW8gOWni+aUr+aMgSBTdHJpbmfvvIzmjIflrprlhbfkvZPlrZfmrrUKICAgICAgICAgICAgcm93S2V5OiB7CiAgICAgICAgICAgICAgICB0eXBlOiBbQm9vbGVhbiwgU3RyaW5nXSwKICAgICAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIC8vIDQuMC4wCiAgICAgICAgICAgIHNwYW5NZXRob2Q6IHsKICAgICAgICAgICAgICAgIHR5cGU6IEZ1bmN0aW9uCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIC8vIDQuMC4wCiAgICAgICAgICAgIHNob3dTdW1tYXJ5OiB7CiAgICAgICAgICAgICAgICB0eXBlOiBCb29sZWFuLAogICAgICAgICAgICAgICAgZGVmYXVsdDogZmFsc2UKICAgICAgICAgICAgfSwKICAgICAgICAgICAgLy8gNC4wLjAKICAgICAgICAgICAgc3VtbWFyeU1ldGhvZDogewogICAgICAgICAgICAgICAgdHlwZTogRnVuY3Rpb24KICAgICAgICAgICAgfSwKICAgICAgICAgICAgLy8gNC4wLjAKICAgICAgICAgICAgc3VtVGV4dDogewogICAgICAgICAgICAgICAgdHlwZTogU3RyaW5nCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIC8vIDQuMS4wCiAgICAgICAgICAgIGluZGVudFNpemU6IHsKICAgICAgICAgICAgICAgIHR5cGU6IE51bWJlciwKICAgICAgICAgICAgICAgIGRlZmF1bHQ6IDE2CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIC8vIDQuMS4wCiAgICAgICAgICAgIGxvYWREYXRhOiB7CiAgICAgICAgICAgICAgICB0eXBlOiBGdW5jdGlvbgogICAgICAgICAgICB9LAogICAgICAgICAgICAvLyA0LjEuMAogICAgICAgICAgICBjb250ZXh0TWVudTogewogICAgICAgICAgICAgICAgdHlwZTogQm9vbGVhbiwKICAgICAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIC8vIDQuMi4wCiAgICAgICAgICAgIHNob3dDb250ZXh0TWVudTogewogICAgICAgICAgICAgICAgdHlwZTogQm9vbGVhbiwKICAgICAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlCiAgICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgIGRhdGEgKCkgewogICAgICAgICAgICBjb25zdCBjb2xzV2l0aElkID0gdGhpcy5tYWtlQ29sdW1uc0lkKHRoaXMuY29sdW1ucyk7CiAgICAgICAgICAgIHJldHVybiB7CiAgICAgICAgICAgICAgICByZWFkeTogZmFsc2UsCiAgICAgICAgICAgICAgICB0YWJsZVdpZHRoOiAwLAogICAgICAgICAgICAgICAgY29sdW1uc1dpZHRoOiB7fSwKICAgICAgICAgICAgICAgIHByZWZpeENsczogcHJlZml4Q2xzLAogICAgICAgICAgICAgICAgY29tcGlsZWRVaWRzOiBbXSwKICAgICAgICAgICAgICAgIG9iakRhdGE6IHRoaXMubWFrZU9iakRhdGEoKSwgICAgIC8vIGNoZWNrYm94IG9yIGhpZ2hsaWdodC1yb3cKICAgICAgICAgICAgICAgIHJlYnVpbGREYXRhOiBbXSwgICAgLy8gZm9yIHNvcnQgb3IgZmlsdGVyCiAgICAgICAgICAgICAgICBjbG9uZUNvbHVtbnM6IHRoaXMubWFrZUNvbHVtbnMoY29sc1dpdGhJZCksCiAgICAgICAgICAgICAgICBjb2x1bW5Sb3dzOiB0aGlzLm1ha2VDb2x1bW5Sb3dzKGZhbHNlLCBjb2xzV2l0aElkKSwKICAgICAgICAgICAgICAgIGxlZnRGaXhlZENvbHVtblJvd3M6IHRoaXMubWFrZUNvbHVtblJvd3MoJ2xlZnQnLCBjb2xzV2l0aElkKSwKICAgICAgICAgICAgICAgIHJpZ2h0Rml4ZWRDb2x1bW5Sb3dzOiB0aGlzLm1ha2VDb2x1bW5Sb3dzKCdyaWdodCcsIGNvbHNXaXRoSWQpLAogICAgICAgICAgICAgICAgYWxsQ29sdW1uczogZ2V0QWxsQ29sdW1ucyhjb2xzV2l0aElkKSwgIC8vIGZvciBtdWx0aXBsZSB0YWJsZS1oZWFkLCBnZXQgY29sdW1ucyB0aGF0IGhhdmUgbm8gY2hpbGRyZW4KICAgICAgICAgICAgICAgIHNob3dTbG90SGVhZGVyOiB0cnVlLAogICAgICAgICAgICAgICAgc2hvd1Nsb3RGb290ZXI6IHRydWUsCiAgICAgICAgICAgICAgICBib2R5SGVpZ2h0OiAwLAogICAgICAgICAgICAgICAgc2Nyb2xsQmFyV2lkdGg6IGdldFNjcm9sbEJhclNpemUoKSwKICAgICAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0OiB0aGlzLmNvbnRleHQsCiAgICAgICAgICAgICAgICBjbG9uZURhdGE6IGRlZXBDb3B5KHRoaXMuZGF0YSksICAgIC8vIHdoZW4gQ2VsbCBoYXMgYSBidXR0b24gdG8gZGVsZXRlIHJvdyBkYXRhLCBjbGlja0N1cnJlbnRSb3cgd2lsbCB0aHJvdyBhbiBlcnJvciwgc28gY2xvbmUgYSBkYXRhCiAgICAgICAgICAgICAgICBzaG93VmVydGljYWxTY3JvbGxCYXI6ZmFsc2UsCiAgICAgICAgICAgICAgICBzaG93SG9yaXpvbnRhbFNjcm9sbEJhcjpmYWxzZSwKICAgICAgICAgICAgICAgIGhlYWRlcldpZHRoOjAsCiAgICAgICAgICAgICAgICBoZWFkZXJIZWlnaHQ6MCwKICAgICAgICAgICAgICAgIHNob3dSZXNpemVMaW5lOiBmYWxzZSwKICAgICAgICAgICAgICAgIGNvbnRleHRNZW51VmlzaWJsZTogZmFsc2UsCiAgICAgICAgICAgICAgICBjb250ZXh0TWVudVN0eWxlczogewogICAgICAgICAgICAgICAgICAgIHRvcDogMCwKICAgICAgICAgICAgICAgICAgICBsZWZ0OiAwCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH07CiAgICAgICAgfSwKICAgICAgICBjb21wdXRlZDogewogICAgICAgICAgICBsb2NhbGVOb0RhdGFUZXh0ICgpIHsKICAgICAgICAgICAgICAgIGlmICh0aGlzLm5vRGF0YVRleHQgPT09IHVuZGVmaW5lZCkgewogICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnQoJ2kudGFibGUubm9EYXRhVGV4dCcpOwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ub0RhdGFUZXh0OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9LAogICAgICAgICAgICBsb2NhbGVOb0ZpbHRlcmVkRGF0YVRleHQgKCkgewogICAgICAgICAgICAgICAgaWYgKHRoaXMubm9GaWx0ZXJlZERhdGFUZXh0ID09PSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50KCdpLnRhYmxlLm5vRmlsdGVyZWREYXRhVGV4dCcpOwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ub0ZpbHRlcmVkRGF0YVRleHQ7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGxvY2FsZVN1bVRleHQgKCkgewogICAgICAgICAgICAgICAgaWYgKHRoaXMuc3VtVGV4dCA9PT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudCgnaS50YWJsZS5zdW1UZXh0Jyk7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN1bVRleHQ7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHdyYXBDbGFzc2VzICgpIHsKICAgICAgICAgICAgICAgIHJldHVybiBbCiAgICAgICAgICAgICAgICAgICAgYCR7cHJlZml4Q2xzfS13cmFwcGVyYCwKICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgIFtgJHtwcmVmaXhDbHN9LWhpZGVgXTogIXRoaXMucmVhZHksCiAgICAgICAgICAgICAgICAgICAgICAgIFtgJHtwcmVmaXhDbHN9LXdpdGgtaGVhZGVyYF06IHRoaXMuc2hvd1Nsb3RIZWFkZXIsCiAgICAgICAgICAgICAgICAgICAgICAgIFtgJHtwcmVmaXhDbHN9LXdpdGgtZm9vdGVyYF06IHRoaXMuc2hvd1Nsb3RGb290ZXIsCiAgICAgICAgICAgICAgICAgICAgICAgIFtgJHtwcmVmaXhDbHN9LXdpdGgtc3VtbWFyeWBdOiB0aGlzLnNob3dTdW1tYXJ5LAogICAgICAgICAgICAgICAgICAgICAgICBbYCR7cHJlZml4Q2xzfS13cmFwcGVyLXdpdGgtYm9yZGVyYF06IHRoaXMuYm9yZGVyCiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgXTsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgY2xhc3NlcyAoKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gWwogICAgICAgICAgICAgICAgICAgIGAke3ByZWZpeENsc31gLAogICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgW2Ake3ByZWZpeENsc30tJHt0aGlzLnNpemV9YF06ICEhdGhpcy5zaXplLAogICAgICAgICAgICAgICAgICAgICAgICBbYCR7cHJlZml4Q2xzfS1ib3JkZXJgXTogdGhpcy5ib3JkZXIsCiAgICAgICAgICAgICAgICAgICAgICAgIFtgJHtwcmVmaXhDbHN9LXN0cmlwZWBdOiB0aGlzLnN0cmlwZSwKICAgICAgICAgICAgICAgICAgICAgICAgW2Ake3ByZWZpeENsc30td2l0aC1maXhlZC10b3BgXTogISF0aGlzLmhlaWdodAogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIF07CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGZpeGVkSGVhZGVyQ2xhc3NlcyAoKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gWwogICAgICAgICAgICAgICAgICAgIGAke3ByZWZpeENsc30tZml4ZWQtaGVhZGVyYCwKICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgIFtgJHtwcmVmaXhDbHN9LWZpeGVkLWhlYWRlci13aXRoLWVtcHR5YF06ICF0aGlzLnJlYnVpbGREYXRhLmxlbmd0aAogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIF07CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHN0eWxlcyAoKSB7CiAgICAgICAgICAgICAgICBsZXQgc3R5bGUgPSB7fTsKICAgICAgICAgICAgICAgIGxldCBzdW1tYXJ5SGVpZ2h0ID0gMDsKICAgICAgICAgICAgICAgIGlmICh0aGlzLnNob3dTdW1tYXJ5KSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2l6ZSA9PT0gJ3NtYWxsJykgc3VtbWFyeUhlaWdodCA9IDQwOwogICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc2l6ZSA9PT0gJ2xhcmdlJykgc3VtbWFyeUhlaWdodCA9IDYwOwogICAgICAgICAgICAgICAgICAgIGVsc2Ugc3VtbWFyeUhlaWdodCA9IDQ4OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHRoaXMuaGVpZ2h0KSB7CiAgICAgICAgICAgICAgICAgICAgbGV0IGhlaWdodCA9IHBhcnNlSW50KHRoaXMuaGVpZ2h0KSArIHN1bW1hcnlIZWlnaHQ7CiAgICAgICAgICAgICAgICAgICAgc3R5bGUuaGVpZ2h0ID0gYCR7aGVpZ2h0fXB4YDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmICh0aGlzLm1heEhlaWdodCkgewogICAgICAgICAgICAgICAgICAgIGNvbnN0IG1heEhlaWdodCA9IHBhcnNlSW50KHRoaXMubWF4SGVpZ2h0KSArIHN1bW1hcnlIZWlnaHQ7CiAgICAgICAgICAgICAgICAgICAgc3R5bGUubWF4SGVpZ2h0ID0gYCR7bWF4SGVpZ2h0fXB4YDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmICh0aGlzLndpZHRoKSBzdHlsZS53aWR0aCA9IGAke3RoaXMud2lkdGh9cHhgOwogICAgICAgICAgICAgICAgcmV0dXJuIHN0eWxlOwogICAgICAgICAgICB9LAogICAgICAgICAgICB0YWJsZVN0eWxlICgpIHsKICAgICAgICAgICAgICAgIGxldCBzdHlsZSA9IHt9OwogICAgICAgICAgICAgICAgaWYgKHRoaXMudGFibGVXaWR0aCAhPT0gMCkgewogICAgICAgICAgICAgICAgICAgIGxldCB3aWR0aCA9ICcnOwogICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmJvZHlIZWlnaHQgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggPSB0aGlzLnRhYmxlV2lkdGg7CiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggPSB0aGlzLnRhYmxlV2lkdGggLSAodGhpcy5zaG93VmVydGljYWxTY3JvbGxCYXI/dGhpcy5zY3JvbGxCYXJXaWR0aDowKTsKICAgICAgICAgICAgICAgICAgICB9Ci8vICAgICAgICAgICAgICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuYm9keUhlaWdodCA9PT0gMCA/IHRoaXMudGFibGVXaWR0aCA6IHRoaXMudGFibGVXaWR0aCAtIHRoaXMuc2Nyb2xsQmFyV2lkdGg7CiAgICAgICAgICAgICAgICAgICAgc3R5bGUud2lkdGggPSBgJHt3aWR0aH1weGA7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICByZXR1cm4gc3R5bGU7CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHRhYmxlSGVhZGVyU3R5bGUgKCkgewogICAgICAgICAgICAgICAgbGV0IHN0eWxlID0ge307CiAgICAgICAgICAgICAgICBpZiAodGhpcy50YWJsZVdpZHRoICE9PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgbGV0IHdpZHRoID0gJyc7CiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSB0aGlzLnRhYmxlV2lkdGg7CiAgICAgICAgICAgICAgICAgICAgc3R5bGUud2lkdGggPSBgJHt3aWR0aH1weGA7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICByZXR1cm4gc3R5bGU7CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGZpeGVkVGFibGVTdHlsZSAoKSB7CiAgICAgICAgICAgICAgICBsZXQgc3R5bGUgPSB7fTsKICAgICAgICAgICAgICAgIGxldCB3aWR0aCA9IDA7CiAgICAgICAgICAgICAgICB0aGlzLmxlZnRGaXhlZENvbHVtbnMuZm9yRWFjaCgoY29sKSA9PiB7CiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbC5maXhlZCAmJiBjb2wuZml4ZWQgPT09ICdsZWZ0Jykgd2lkdGggKz0gY29sLl93aWR0aDsKICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgc3R5bGUud2lkdGggPSBgJHt3aWR0aH1weGA7CiAgICAgICAgICAgICAgICByZXR1cm4gc3R5bGU7CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGZpeGVkUmlnaHRUYWJsZVN0eWxlICgpIHsKICAgICAgICAgICAgICAgIGxldCBzdHlsZSA9IHt9OwogICAgICAgICAgICAgICAgbGV0IHdpZHRoID0gMDsKICAgICAgICAgICAgICAgIHRoaXMucmlnaHRGaXhlZENvbHVtbnMuZm9yRWFjaCgoY29sKSA9PiB7CiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbC5maXhlZCAmJiBjb2wuZml4ZWQgPT09ICdyaWdodCcpIHdpZHRoICs9IGNvbC5fd2lkdGg7CiAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgIC8vd2lkdGggKz0gdGhpcy5zY3JvbGxCYXJXaWR0aDsKICAgICAgICAgICAgICAgIHN0eWxlLndpZHRoID0gYCR7d2lkdGh9cHhgOwogICAgICAgICAgICAgICAgc3R5bGUucmlnaHQgPSBgJHt0aGlzLnNob3dWZXJ0aWNhbFNjcm9sbEJhcj90aGlzLnNjcm9sbEJhcldpZHRoOjB9cHhgOwogICAgICAgICAgICAgICAgcmV0dXJuIHN0eWxlOwogICAgICAgICAgICB9LAogICAgICAgICAgICBmaXhlZFJpZ2h0SGVhZGVyU3R5bGUgKCkgewogICAgICAgICAgICAgICAgbGV0IHN0eWxlID0ge307CiAgICAgICAgICAgICAgICBsZXQgd2lkdGggPSAwOwogICAgICAgICAgICAgICAgbGV0IGhlaWdodCA9IHRoaXMuaGVhZGVySGVpZ2h0KzE7CiAgICAgICAgICAgICAgICBpZih0aGlzLnNob3dWZXJ0aWNhbFNjcm9sbEJhcil7CiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSB0aGlzLnNjcm9sbEJhcldpZHRoOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3R5bGUud2lkdGggPSBgJHt3aWR0aH1weGA7CiAgICAgICAgICAgICAgICBzdHlsZS5oZWlnaHQgPSBgJHtoZWlnaHR9cHhgOwogICAgICAgICAgICAgICAgcmV0dXJuIHN0eWxlOwogICAgICAgICAgICB9LAogICAgICAgICAgICBib2R5U3R5bGUgKCkgewogICAgICAgICAgICAgICAgbGV0IHN0eWxlID0ge307CiAgICAgICAgICAgICAgICBpZiAodGhpcy5ib2R5SGVpZ2h0ICE9PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5ib2R5SGVpZ2h0OwogICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmhlaWdodCkgewogICAgICAgICAgICAgICAgICAgICAgICBzdHlsZS5oZWlnaHQgPSBgJHtoZWlnaHR9cHhgOwogICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5tYXhIZWlnaHQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUubWF4SGVpZ2h0ID0gYCR7aGVpZ2h0fXB4YDsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICByZXR1cm4gc3R5bGU7CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGZpeGVkQm9keVN0eWxlICgpIHsKICAgICAgICAgICAgICAgIGxldCBzdHlsZSA9IHt9OwogICAgICAgICAgICAgICAgaWYgKHRoaXMuYm9keUhlaWdodCAhPT0gMCkgewogICAgICAgICAgICAgICAgICAgIGxldCBoZWlnaHQgPSB0aGlzLmJvZHlIZWlnaHQgLSAodGhpcy5zaG93SG9yaXpvbnRhbFNjcm9sbEJhcj90aGlzLnNjcm9sbEJhcldpZHRoOjApOwogICAgICAgICAgICAgICAgICAgIHN0eWxlLmhlaWdodCA9IHRoaXMuc2hvd0hvcml6b250YWxTY3JvbGxCYXIgPyBgJHtoZWlnaHR9cHhgIDogYCR7aGVpZ2h0IC0gMX1weGA7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICByZXR1cm4gc3R5bGU7CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGxlZnRGaXhlZENvbHVtbnMgKCkgewogICAgICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRDb2x1bW5PcmRlcih0aGlzLmNsb25lQ29sdW1ucywgJ2xlZnQnKTsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgcmlnaHRGaXhlZENvbHVtbnMgKCkgewogICAgICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRDb2x1bW5PcmRlcih0aGlzLmNsb25lQ29sdW1ucywgJ3JpZ2h0Jyk7CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGlzTGVmdEZpeGVkICgpIHsKICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnMuc29tZShjb2wgPT4gY29sLmZpeGVkICYmIGNvbC5maXhlZCA9PT0gJ2xlZnQnKTsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgaXNSaWdodEZpeGVkICgpIHsKICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnMuc29tZShjb2wgPT4gY29sLmZpeGVkICYmIGNvbC5maXhlZCA9PT0gJ3JpZ2h0Jyk7CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIC8vIGZvciBzdW1tYXJ5IGRhdGEKICAgICAgICAgICAgc3VtbWFyeURhdGEgKCkgewogICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNob3dTdW1tYXJ5KSByZXR1cm4ge307CgogICAgICAgICAgICAgICAgbGV0IHN1bXMgPSB7fTsKICAgICAgICAgICAgICAgIGlmICh0aGlzLnN1bW1hcnlNZXRob2QpIHsKICAgICAgICAgICAgICAgICAgICBzdW1zID0gdGhpcy5zdW1tYXJ5TWV0aG9kKHsgY29sdW1uczogdGhpcy5jbG9uZUNvbHVtbnMsIGRhdGE6IHRoaXMucmVidWlsZERhdGEgfSk7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvbmVDb2x1bW5zLmZvckVhY2goKGNvbHVtbiwgaW5kZXgpID0+IHsKICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gY29sdW1uLmtleTsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdW1zW2tleV0gPSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBjb2x1bW4ua2V5LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLmxvY2FsZVN1bVRleHQKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07CiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gdGhpcy5yZWJ1aWxkRGF0YS5tYXAoaXRlbSA9PiBOdW1iZXIoaXRlbVtjb2x1bW4ua2V5XSkpOwogICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmVjaXNpb25zID0gW107CiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBub3ROdW1iZXIgPSB0cnVlOwogICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMuZm9yRWFjaCh2YWx1ZSA9PiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKHZhbHVlKSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdE51bWJlciA9IGZhbHNlOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkZWNpbWFsID0gKCcnICsgdmFsdWUpLnNwbGl0KCcuJylbMV07CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlY2lzaW9ucy5wdXNoKGRlY2ltYWwgPyBkZWNpbWFsLmxlbmd0aCA6IDApOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJlY2lzaW9uID0gTWF0aC5tYXguYXBwbHkobnVsbCwgcHJlY2lzaW9ucyk7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbm90TnVtYmVyKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB2YWx1ZXMucmVkdWNlKChwcmV2LCBjdXJyKSA9PiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBOdW1iZXIoY3Vycik7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc05hTih2YWx1ZSkpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoKHByZXYgKyBjdXJyKS50b0ZpeGVkKE1hdGgubWluKHByZWNpc2lvbiwgMjApKSk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZXY7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgMCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdW1zW2tleV0gPSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBjb2x1bW4ua2V5LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjdXJyZW50VmFsdWUKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07CiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdW1zW2tleV0gPSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBjb2x1bW4ua2V5LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiAnJwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIHJldHVybiBzdW1zOwogICAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICBtZXRob2RzOiB7CiAgICAgICAgICAgIHJvd0Nsc05hbWUgKGluZGV4KSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yb3dDbGFzc05hbWUodGhpcy5kYXRhW2luZGV4XSwgaW5kZXgpOwogICAgICAgICAgICB9LAogICAgICAgICAgICBoYW5kbGVSZXNpemUgKCkgewogICAgICAgICAgICAgICAgICAgIC8vbGV0IHRhYmxlV2lkdGggPSBwYXJzZUludChnZXRTdHlsZSh0aGlzLiRlbCwgJ3dpZHRoJykpIC0gMTsKICAgICAgICAgICAgICAgIGxldCB0YWJsZVdpZHRoID0gdGhpcy4kZWwub2Zmc2V0V2lkdGggLSAxOwogICAgICAgICAgICAgICAgbGV0IGNvbHVtbnNXaWR0aCA9IHt9OwogICAgICAgICAgICAgICAgbGV0IHN1bU1pbldpZHRoID0gMDsKICAgICAgICAgICAgICAgIGxldCBoYXNXaWR0aENvbHVtbnMgPSBbXTsKICAgICAgICAgICAgICAgIGxldCBub1dpZHRoQ29sdW1ucyA9IFtdOwogICAgICAgICAgICAgICAgbGV0IG1heFdpZHRoQ29sdW1ucyA9IFtdOwogICAgICAgICAgICAgICAgbGV0IG5vTWF4V2lkdGhDb2x1bW5zID0gW107CiAgICAgICAgICAgICAgICB0aGlzLmNsb25lQ29sdW1ucy5mb3JFYWNoKChjb2wpID0+IHsKICAgICAgICAgICAgICAgICAgICBpZiAoY29sLndpZHRoKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGhhc1dpZHRoQ29sdW1ucy5wdXNoKGNvbCk7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGVsc2V7CiAgICAgICAgICAgICAgICAgICAgICAgIG5vV2lkdGhDb2x1bW5zLnB1c2goY29sKTsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbC5taW5XaWR0aCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VtTWluV2lkdGggKz0gY29sLm1pbldpZHRoOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2wubWF4V2lkdGgpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heFdpZHRoQ29sdW1ucy5wdXNoKGNvbCk7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub01heFdpZHRoQ29sdW1ucy5wdXNoKGNvbCk7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgY29sLl93aWR0aCA9IG51bGw7CiAgICAgICAgICAgICAgICB9KTsKCgogICAgICAgICAgICAgICAgbGV0IHVuVXNhYmxlV2lkdGggPSBoYXNXaWR0aENvbHVtbnMubWFwKGNlbGwgPT4gY2VsbC53aWR0aCkucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCk7CiAgICAgICAgICAgICAgICBsZXQgdXNhYmxlV2lkdGggPSB0YWJsZVdpZHRoIC0gdW5Vc2FibGVXaWR0aCAtIHN1bU1pbldpZHRoIC0gKHRoaXMuc2hvd1ZlcnRpY2FsU2Nyb2xsQmFyP3RoaXMuc2Nyb2xsQmFyV2lkdGg6MCkgLSAxOwogICAgICAgICAgICAgICAgbGV0IHVzYWJsZUxlbmd0aCA9IG5vV2lkdGhDb2x1bW5zLmxlbmd0aDsKICAgICAgICAgICAgICAgIGxldCBjb2x1bW5XaWR0aCA9IDA7CiAgICAgICAgICAgICAgICBpZih1c2FibGVXaWR0aCA+IDAgJiYgdXNhYmxlTGVuZ3RoID4gMCl7CiAgICAgICAgICAgICAgICAgICAgY29sdW1uV2lkdGggPSBwYXJzZUludCh1c2FibGVXaWR0aCAvIHVzYWJsZUxlbmd0aCk7CiAgICAgICAgICAgICAgICB9CgoKICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jbG9uZUNvbHVtbnMubGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2x1bW4gPSB0aGlzLmNsb25lQ29sdW1uc1tpXTsKICAgICAgICAgICAgICAgICAgICBsZXQgd2lkdGggPSBjb2x1bW5XaWR0aCArIChjb2x1bW4ubWluV2lkdGg/Y29sdW1uLm1pbldpZHRoOjApOwogICAgICAgICAgICAgICAgICAgIGlmKGNvbHVtbi53aWR0aCl7CiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoID0gY29sdW1uLndpZHRoOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBlbHNlewogICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sdW1uLl93aWR0aCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBjb2x1bW4uX3dpZHRoOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbHVtbi5taW5XaWR0aCA+IHdpZHRoKXsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IGNvbHVtbi5taW5XaWR0aDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbHVtbi5tYXhXaWR0aCA8IHdpZHRoKXsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IGNvbHVtbi5tYXhXaWR0aDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXNhYmxlV2lkdGg+MCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzYWJsZVdpZHRoIC09IHdpZHRoIC0gKGNvbHVtbi5taW5XaWR0aD9jb2x1bW4ubWluV2lkdGg6MCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNhYmxlTGVuZ3RoLS07CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVzYWJsZUxlbmd0aCA+IDApIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uV2lkdGggPSBwYXJzZUludCh1c2FibGVXaWR0aCAvIHVzYWJsZUxlbmd0aCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5XaWR0aCA9IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZXsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5XaWR0aCA9IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgIGNvbHVtbi5fd2lkdGggPSB3aWR0aDsKCiAgICAgICAgICAgICAgICAgICAgY29sdW1uc1dpZHRoW2NvbHVtbi5faW5kZXhdID0gewogICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgKICAgICAgICAgICAgICAgICAgICB9OwoKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmKHVzYWJsZVdpZHRoPjApIHsKICAgICAgICAgICAgICAgICAgICB1c2FibGVMZW5ndGggPSBub01heFdpZHRoQ29sdW1ucy5sZW5ndGg7CiAgICAgICAgICAgICAgICAgICAgY29sdW1uV2lkdGggPSBwYXJzZUludCh1c2FibGVXaWR0aCAvIHVzYWJsZUxlbmd0aCk7CiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub01heFdpZHRoQ29sdW1ucy5sZW5ndGg7IGkrKykgewogICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2x1bW4gPSBub01heFdpZHRoQ29sdW1uc1tpXTsKICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHdpZHRoID0gY29sdW1uLl93aWR0aCArIGNvbHVtbldpZHRoOwogICAgICAgICAgICAgICAgICAgICAgICBpZiAodXNhYmxlTGVuZ3RoID4gMSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNhYmxlTGVuZ3RoLS07CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2FibGVXaWR0aCAtPSBjb2x1bW5XaWR0aDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbldpZHRoID0gcGFyc2VJbnQodXNhYmxlV2lkdGggLyB1c2FibGVMZW5ndGgpOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uV2lkdGggPSAwOwogICAgICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW4uX3dpZHRoID0gd2lkdGg7CgogICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5zV2lkdGhbY29sdW1uLl9pbmRleF0gPSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgKICAgICAgICAgICAgICAgICAgICAgICAgfTsKCiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIHRoaXMudGFibGVXaWR0aCA9IHRoaXMuY2xvbmVDb2x1bW5zLm1hcChjZWxsID0+IGNlbGwuX3dpZHRoKS5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSArICh0aGlzLnNob3dWZXJ0aWNhbFNjcm9sbEJhcj90aGlzLnNjcm9sbEJhcldpZHRoOjApICsgMTsKICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uc1dpZHRoID0gY29sdW1uc1dpZHRoOwogICAgICAgICAgICAgICAgdGhpcy5maXhlZEhlYWRlcigpOwogICAgICAgICAgICB9LAogICAgICAgICAgICBoYW5kbGVNb3VzZUluIChfaW5kZXgsIHJvd0tleSkgewogICAgICAgICAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWRIb3ZlcikgcmV0dXJuOwogICAgICAgICAgICAgICAgY29uc3Qgb2JqRGF0YSA9IHJvd0tleSA/IHRoaXMuZ2V0RGF0YUJ5Um93S2V5KHJvd0tleSkgOiB0aGlzLm9iakRhdGFbX2luZGV4XTsKICAgICAgICAgICAgICAgIGlmIChvYmpEYXRhLl9pc0hvdmVyKSByZXR1cm47CiAgICAgICAgICAgICAgICBvYmpEYXRhLl9pc0hvdmVyID0gdHJ1ZTsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgaGFuZGxlTW91c2VPdXQgKF9pbmRleCwgcm93S2V5KSB7CiAgICAgICAgICAgICAgICBpZiAodGhpcy5kaXNhYmxlZEhvdmVyKSByZXR1cm47CiAgICAgICAgICAgICAgICBjb25zdCBvYmpEYXRhID0gcm93S2V5ID8gdGhpcy5nZXREYXRhQnlSb3dLZXkocm93S2V5KSA6IHRoaXMub2JqRGF0YVtfaW5kZXhdOwogICAgICAgICAgICAgICAgb2JqRGF0YS5faXNIb3ZlciA9IGZhbHNlOwogICAgICAgICAgICB9LAogICAgICAgICAgICAvLyDpgJrnlKjlpITnkIYgaGlnaGxpZ2h0Q3VycmVudFJvdyDlkowgY2xlYXJDdXJyZW50Um93CiAgICAgICAgICAgIGhhbmRsZUN1cnJlbnRSb3cgKHR5cGUsIF9pbmRleCwgcm93S2V5KSB7CiAgICAgICAgICAgICAgICBjb25zdCBvYmpEYXRhID0gcm93S2V5ID8gdGhpcy5nZXREYXRhQnlSb3dLZXkocm93S2V5KSA6IHRoaXMub2JqRGF0YVtfaW5kZXhdOwoKICAgICAgICAgICAgICAgIGxldCBvbGREYXRhID0gbnVsbDsKICAgICAgICAgICAgICAgIGxldCBvbGRJbmRleCA9IC0xOwoKICAgICAgICAgICAgICAgIGZvciAobGV0IGkgaW4gdGhpcy5vYmpEYXRhKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub2JqRGF0YVtpXS5faXNIaWdobGlnaHQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgb2xkSW5kZXggPSBwYXJzZUludChpKTsKICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vYmpEYXRhW2ldLl9pc0hpZ2hsaWdodCA9IGZhbHNlOwogICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMub2JqRGF0YVtpXS5jaGlsZHJlbiAmJiB0aGlzLm9iakRhdGFbaV0uY2hpbGRyZW4ubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc2V0RGF0YSA9IHRoaXMuaGFuZGxlUmVzZXRDaGlsZHJlblJvdyh0aGlzLm9iakRhdGFbaV0pOwogICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzZXREYXRhKSBvbGREYXRhID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShyZXNldERhdGEpKTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2hpZ2hsaWdodCcpIG9iakRhdGEuX2lzSGlnaGxpZ2h0ID0gdHJ1ZTsKICAgICAgICAgICAgICAgIGlmIChvbGRJbmRleCA+PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgb2xkRGF0YSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5jbG9uZURhdGFbb2xkSW5kZXhdKSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBjb25zdCBuZXdEYXRhID0gdHlwZSA9PT0gJ2hpZ2hsaWdodCcgPyByb3dLZXkgPyBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMuZ2V0QmFzZURhdGFCeVJvd0tleShyb3dLZXkpKSkgOiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMuY2xvbmVEYXRhW19pbmRleF0pKSA6IG51bGw7CiAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdvbi1jdXJyZW50LWNoYW5nZScsIG5ld0RhdGEsIG9sZERhdGEpOwogICAgICAgICAgICB9LAogICAgICAgICAgICBoYW5kbGVSZXNldENoaWxkcmVuUm93IChvYmpEYXRhKSB7CiAgICAgICAgICAgICAgICBsZXQgZGF0YSA9IG51bGw7CiAgICAgICAgICAgICAgICBpZiAob2JqRGF0YS5jaGlsZHJlbiAmJiBvYmpEYXRhLmNoaWxkcmVuLmxlbmd0aCkgewogICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqRGF0YS5jaGlsZHJlbi5sZW5ndGg7IGkrKykgewogICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gb2JqRGF0YS5jaGlsZHJlbltpXTsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uX2lzSGlnaGxpZ2h0KSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLl9pc0hpZ2hsaWdodCA9IGZhbHNlOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGl0ZW07CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpdGVtLmNoaWxkcmVuICYmIGl0ZW0uY2hpbGRyZW4ubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gdGhpcy5oYW5kbGVSZXNldENoaWxkcmVuUm93KGl0ZW0pOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGhpZ2hsaWdodEN1cnJlbnRSb3cgKF9pbmRleCwgcm93S2V5KSB7CiAgICAgICAgICAgICAgICBjb25zdCBvYmpEYXRhID0gcm93S2V5ID8gdGhpcy5nZXREYXRhQnlSb3dLZXkocm93S2V5KSA6IHRoaXMub2JqRGF0YVtfaW5kZXhdOwogICAgICAgICAgICAgICAgaWYgKCF0aGlzLmhpZ2hsaWdodFJvdyB8fCBvYmpEYXRhLl9pc0hpZ2hsaWdodCkgcmV0dXJuOwogICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVDdXJyZW50Um93KCdoaWdobGlnaHQnLCBfaW5kZXgsIHJvd0tleSk7CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGNsZWFyQ3VycmVudFJvdyAoKSB7CiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaGlnaGxpZ2h0Um93KSByZXR1cm47CiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUN1cnJlbnRSb3coJ2NsZWFyJyk7CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGNsaWNrQ3VycmVudFJvdyAoX2luZGV4LCByb3dLZXkpIHsKICAgICAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0Q3VycmVudFJvdyAoX2luZGV4LCByb3dLZXkpOwogICAgICAgICAgICAgICAgaWYgKHJvd0tleSkgewogICAgICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ29uLXJvdy1jbGljaycsIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5nZXRCYXNlRGF0YUJ5Um93S2V5KHJvd0tleSkpKSk7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ29uLXJvdy1jbGljaycsIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5jbG9uZURhdGFbX2luZGV4XSkpLCBfaW5kZXgpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9LAogICAgICAgICAgICBkYmxjbGlja0N1cnJlbnRSb3cgKF9pbmRleCwgcm93S2V5KSB7CiAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodEN1cnJlbnRSb3cgKF9pbmRleCwgcm93S2V5KTsKICAgICAgICAgICAgICAgIGlmIChyb3dLZXkpIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdvbi1yb3ctZGJsY2xpY2snLCBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMuZ2V0QmFzZURhdGFCeVJvd0tleShyb3dLZXkpKSkpOwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdvbi1yb3ctZGJsY2xpY2snLCBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMuY2xvbmVEYXRhW19pbmRleF0pKSwgX2luZGV4KTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSwKICAgICAgICAgICAgY29udGV4dG1lbnVDdXJyZW50Um93IChfaW5kZXgsIHJvd0tleSwgZXZlbnQpIHsKICAgICAgICAgICAgICAgIGNvbnN0ICRUYWJsZVdyYXAgPSB0aGlzLiRyZWZzLnRhYmxlV3JhcDsKICAgICAgICAgICAgICAgIGNvbnN0IFRhYmxlQm91bmRpbmcgPSAkVGFibGVXcmFwLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOwogICAgICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSB7CiAgICAgICAgICAgICAgICAgICAgbGVmdDogYCR7ZXZlbnQuY2xpZW50WCAtIFRhYmxlQm91bmRpbmcubGVmdH1weGAsCiAgICAgICAgICAgICAgICAgICAgdG9wOiBgJHtldmVudC5jbGllbnRZIC0gVGFibGVCb3VuZGluZy50b3B9cHhgCiAgICAgICAgICAgICAgICB9OwogICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0TWVudVN0eWxlcyA9IHBvc2l0aW9uOwogICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0TWVudVZpc2libGUgPSB0cnVlOwogICAgICAgICAgICAgICAgaWYgKHJvd0tleSkgewogICAgICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ29uLWNvbnRleHRtZW51JywgSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLmdldEJhc2VEYXRhQnlSb3dLZXkocm93S2V5KSkpLCBldmVudCwgcG9zaXRpb24pOwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdvbi1jb250ZXh0bWVudScsIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5jbG9uZURhdGFbX2luZGV4XSkpLCBldmVudCwgcG9zaXRpb24pOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9LAogICAgICAgICAgICBnZXRTZWxlY3Rpb24gKCkgewogICAgICAgICAgICAgICAgLy8g5YiG5Yir5ou/5qC55pWw5o2u5ZKM5a2Q5pWw5o2u55qE5bey6YCJ6aG5CiAgICAgICAgICAgICAgICBsZXQgc2VsZWN0aW9uSW5kZXhlcyA9IFtdOwogICAgICAgICAgICAgICAgbGV0IHNlbGVjdGlvblJvd0tleXMgPSBbXTsKICAgICAgICAgICAgICAgIGZvciAobGV0IGkgaW4gdGhpcy5vYmpEYXRhKSB7CiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2JqRGF0YSA9IHRoaXMub2JqRGF0YVtpXTsKICAgICAgICAgICAgICAgICAgICBpZiAob2JqRGF0YS5faXNDaGVja2VkKSBzZWxlY3Rpb25JbmRleGVzLnB1c2gocGFyc2VJbnQoaSkpOwogICAgICAgICAgICAgICAgICAgIGlmIChvYmpEYXRhLmNoaWxkcmVuICYmIG9iakRhdGEuY2hpbGRyZW4ubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvblJvd0tleXMgPSBzZWxlY3Rpb25Sb3dLZXlzLmNvbmNhdCh0aGlzLmdldFNlbGVjdGlvbkNoaWxkcmVuUm93S2V5cyhvYmpEYXRhLCBzZWxlY3Rpb25Sb3dLZXlzKSk7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIC8vIOWOu+mHjeeahCBSb3dLZXlzCiAgICAgICAgICAgICAgICBzZWxlY3Rpb25Sb3dLZXlzID0gWy4uLm5ldyBTZXQoc2VsZWN0aW9uUm93S2V5cyldOwoKICAgICAgICAgICAgICAgIGxldCBzZWxlY3Rpb24gPSBbXTsKCiAgICAgICAgICAgICAgICB0aGlzLmRhdGEuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHsKICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uSW5kZXhlcy5pbmRleE9mKGluZGV4KSA+IC0xKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdGlvbi5jb25jYXQoaXRlbSk7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmNoaWxkcmVuICYmIGl0ZW0uY2hpbGRyZW4ubGVuZ3RoICYmIHNlbGVjdGlvblJvd0tleXMubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdGlvbi5jb25jYXQodGhpcy5nZXRTZWxlY3Rpb25DaGlsZHJlbihpdGVtLCBzZWxlY3Rpb24sIHNlbGVjdGlvblJvd0tleXMpKTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9KTsKCgogICAgICAgICAgICAgICAgc2VsZWN0aW9uID0gWy4uLm5ldyBTZXQoc2VsZWN0aW9uKV07CiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShzZWxlY3Rpb24pKTsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgZ2V0U2VsZWN0aW9uQ2hpbGRyZW5Sb3dLZXlzIChvYmpEYXRhLCBzZWxlY3Rpb25Sb3dLZXlzKSB7CiAgICAgICAgICAgICAgICBpZiAob2JqRGF0YS5jaGlsZHJlbiAmJiBvYmpEYXRhLmNoaWxkcmVuLmxlbmd0aCkgewogICAgICAgICAgICAgICAgICAgIG9iakRhdGEuY2hpbGRyZW4uZm9yRWFjaChpdGVtID0+IHsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uX2lzQ2hlY2tlZCkgc2VsZWN0aW9uUm93S2V5cy5wdXNoKGl0ZW0uX3Jvd0tleSk7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmNoaWxkcmVuICYmIGl0ZW0uY2hpbGRyZW4ubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25Sb3dLZXlzID0gc2VsZWN0aW9uUm93S2V5cy5jb25jYXQodGhpcy5nZXRTZWxlY3Rpb25DaGlsZHJlblJvd0tleXMoaXRlbSwgc2VsZWN0aW9uUm93S2V5cykpOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZWN0aW9uUm93S2V5czsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgZ2V0U2VsZWN0aW9uQ2hpbGRyZW4gKGRhdGEsIHNlbGVjdGlvbiwgc2VsZWN0aW9uUm93S2V5cykgewogICAgICAgICAgICAgICAgaWYgKGRhdGEuY2hpbGRyZW4gJiYgZGF0YS5jaGlsZHJlbi5sZW5ndGgpIHsKICAgICAgICAgICAgICAgICAgICBkYXRhLmNoaWxkcmVuLmZvckVhY2goaXRlbSA9PiB7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb25Sb3dLZXlzLmluZGV4T2YoaXRlbVt0aGlzLnJvd0tleV0pID4gLTEpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdGlvbi5jb25jYXQoaXRlbSk7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uY2hpbGRyZW4gJiYgaXRlbS5jaGlsZHJlbi5sZW5ndGgpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdGlvbi5jb25jYXQodGhpcy5nZXRTZWxlY3Rpb25DaGlsZHJlbihpdGVtLCBzZWxlY3Rpb24sIHNlbGVjdGlvblJvd0tleXMpKTsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGlvbjsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgdG9nZ2xlU2VsZWN0IChfaW5kZXgsIHJvd0tleSkgewogICAgICAgICAgICAgICAgbGV0IGRhdGEgPSB7fTsKCiAgICAgICAgICAgICAgICBpZiAocm93S2V5KSB7CiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMuZ2V0RGF0YUJ5Um93S2V5KHJvd0tleSk7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgaW4gdGhpcy5vYmpEYXRhKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZUludChpKSA9PT0gX2luZGV4KSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gdGhpcy5vYmpEYXRhW2ldOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBjb25zdCBzdGF0dXMgPSAhZGF0YS5faXNDaGVja2VkOwoKICAgICAgICAgICAgICAgIGRhdGEuX2lzQ2hlY2tlZCA9IHN0YXR1czsKICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHRoaXMuZ2V0U2VsZWN0aW9uKCk7CiAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RlZERhdGEgPSByb3dLZXkgPyB0aGlzLmdldEJhc2VEYXRhQnlSb3dLZXkocm93S2V5LCB0aGlzLmRhdGEpIDogdGhpcy5kYXRhW19pbmRleF07CiAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KHN0YXR1cyA/ICdvbi1zZWxlY3QnIDogJ29uLXNlbGVjdC1jYW5jZWwnLCBzZWxlY3Rpb24sIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoc2VsZWN0ZWREYXRhKSkpOwogICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnb24tc2VsZWN0aW9uLWNoYW5nZScsIHNlbGVjdGlvbik7CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHRvZ2dsZUV4cGFuZCAoX2luZGV4KSB7CiAgICAgICAgICAgICAgICBsZXQgZGF0YSA9IHt9OwoKICAgICAgICAgICAgICAgIGZvciAobGV0IGkgaW4gdGhpcy5vYmpEYXRhKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlSW50KGkpID09PSBfaW5kZXgpIHsKICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMub2JqRGF0YVtpXTsKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gIWRhdGEuX2lzRXhwYW5kZWQ7CiAgICAgICAgICAgICAgICB0aGlzLm9iakRhdGFbX2luZGV4XS5faXNFeHBhbmRlZCA9IHN0YXR1czsKICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ29uLWV4cGFuZCcsIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5jbG9uZURhdGFbX2luZGV4XSkpLCBzdGF0dXMpOwoKICAgICAgICAgICAgICAgIGlmKHRoaXMuaGVpZ2h0IHx8IHRoaXMubWF4SGVpZ2h0KXsKICAgICAgICAgICAgICAgICAgICB0aGlzLiRuZXh0VGljaygoKT0+dGhpcy5maXhlZEJvZHkoKSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHRvZ2dsZVRyZWUgKHJvd0tleSkgewogICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZ2V0RGF0YUJ5Um93S2V5KHJvd0tleSk7CiAgICAgICAgICAgICAgICAvLyBhc3luYyBsb2FkaW5nCiAgICAgICAgICAgICAgICBpZiAoJ19sb2FkaW5nJyBpbiBkYXRhICYmIGRhdGEuX2xvYWRpbmcpIHJldHVybjsKICAgICAgICAgICAgICAgIGlmICgnX2xvYWRpbmcnIGluIGRhdGEgJiYgIWRhdGEuX2xvYWRpbmcgJiYgZGF0YS5jaGlsZHJlbi5sZW5ndGggPT09IDApIHsKICAgICAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2VEYXRhID0gdGhpcy5nZXRCYXNlRGF0YUJ5Um93S2V5KHJvd0tleSwgdGhpcy5kYXRhKTsKICAgICAgICAgICAgICAgICAgICB0aGlzLiRzZXQoc291cmNlRGF0YSwgJ19sb2FkaW5nJywgdHJ1ZSk7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2FkRGF0YShzb3VyY2VEYXRhLCBjaGlsZHJlbiA9PiB7CiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJHNldChzb3VyY2VEYXRhLCAnX2xvYWRpbmcnLCBmYWxzZSk7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGgpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJHNldChzb3VyY2VEYXRhLCAnY2hpbGRyZW4nLCBjaGlsZHJlbik7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRuZXh0VGljaygoKSA9PiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3RGF0YSA9IHRoaXMuZ2V0RGF0YUJ5Um93S2V5KHJvd0tleSk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3RGF0YS5faXNTaG93Q2hpbGRyZW4gPSAhbmV3RGF0YS5faXNTaG93Q2hpbGRyZW47CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVEYXRhU3RhdHVzKHJvd0tleSwgJ19zaG93Q2hpbGRyZW4nLCBuZXdEYXRhLl9pc1Nob3dDaGlsZHJlbik7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICBkYXRhLl9pc1Nob3dDaGlsZHJlbiA9ICFkYXRhLl9pc1Nob3dDaGlsZHJlbjsKICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlRGF0YVN0YXR1cyhyb3dLZXksICdfc2hvd0NoaWxkcmVuJywgZGF0YS5faXNTaG93Q2hpbGRyZW4pOwogICAgICAgICAgICB9LAogICAgICAgICAgICAvKioKICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uIOW9k+S/ruaUueafkOWGhee9ruWxnuaAp++8jOWmgiBfaXNTaG93Q2hpbGRyZW4g5pe277yM5Zug5b2T5bCG5Y6fIGRhdGEg5a+55bqUIF9zaG93Q2hpbGRyZW4g5Lmf5L+u5pS577yM5ZCm5YiZ5L+u5pS5IGRhdGEg5pe277yM54q25oCB5Lya6YeN572uCiAgICAgICAgICAgICAqIEBwYXJhbSByb3dLZXkgcm93S2V5CiAgICAgICAgICAgICAqIEBwYXJhbSBrZXkg5Y6f5pWw5o2u5a+55bqU55qE5a2X5q61CiAgICAgICAgICAgICAqIEBwYXJhbSB2YWx1ZSDkv67mlLnnmoTlgLwKICAgICAgICAgICAgICogKi8KICAgICAgICAgICAgLy8gdG9kbyDljZXpgInjgIHlpJrpgInnrYnnirbmgIHlj6/og73kuZ/pnIDopoHmm7TmlrDljp/mlbDmja4KICAgICAgICAgICAgdXBkYXRlRGF0YVN0YXR1cyAocm93S2V5LCBrZXksIHZhbHVlKSB7CiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5nZXRCYXNlRGF0YUJ5Um93S2V5KHJvd0tleSwgdGhpcy5kYXRhKTsKICAgICAgICAgICAgICAgIHRoaXMuJHNldChkYXRhLCBrZXksIHZhbHVlKTsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgZ2V0RGF0YUJ5Um93S2V5IChyb3dLZXksIG9iakRhdGEgPSB0aGlzLm9iakRhdGEpIHsKICAgICAgICAgICAgICAgIGxldCBkYXRhID0gbnVsbDsKICAgICAgICAgICAgICAgIGZvciAobGV0IGkgaW4gb2JqRGF0YSkgewogICAgICAgICAgICAgICAgICAgIGNvbnN0IHRoaXNEYXRhID0gb2JqRGF0YVtpXTsKICAgICAgICAgICAgICAgICAgICBpZiAodGhpc0RhdGEuX3Jvd0tleSA9PT0gcm93S2V5KSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzRGF0YTsKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzRGF0YS5jaGlsZHJlbiAmJiB0aGlzRGF0YS5jaGlsZHJlbi5sZW5ndGgpIHsKICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMuZ2V0Q2hpbGRyZW5CeVJvd0tleShyb3dLZXksIHRoaXNEYXRhKTsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGdldENoaWxkcmVuQnlSb3dLZXkgKHJvd0tleSwgb2JqRGF0YSkgewogICAgICAgICAgICAgICAgbGV0IGRhdGEgPSBudWxsOwogICAgICAgICAgICAgICAgaWYgKG9iakRhdGEuY2hpbGRyZW4gJiYgb2JqRGF0YS5jaGlsZHJlbi5sZW5ndGgpIHsKICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9iakRhdGEuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IG9iakRhdGEuY2hpbGRyZW5baV07CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLl9yb3dLZXkgPT09IHJvd0tleSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGl0ZW07CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpdGVtLmNoaWxkcmVuICYmIGl0ZW0uY2hpbGRyZW4ubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gdGhpcy5nZXRDaGlsZHJlbkJ5Um93S2V5KHJvd0tleSwgaXRlbSk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGdldEJhc2VEYXRhQnlSb3dLZXkgKHJvd0tleSwgc291cmNlRGF0YSA9IHRoaXMuY2xvbmVEYXRhKSB7CiAgICAgICAgICAgICAgICBsZXQgZGF0YSA9IG51bGw7CiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNvdXJjZURhdGEubGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgICAgICAgICBjb25zdCB0aGlzRGF0YSA9IHNvdXJjZURhdGFbaV07CiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXNEYXRhW3RoaXMucm93S2V5XSA9PT0gcm93S2V5KSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzRGF0YTsKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzRGF0YS5jaGlsZHJlbiAmJiB0aGlzRGF0YS5jaGlsZHJlbi5sZW5ndGgpIHsKICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMuZ2V0Q2hpbGRyZW5EYXRhQnlSb3dLZXkocm93S2V5LCB0aGlzRGF0YSk7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhICYmIGRhdGFbdGhpcy5yb3dLZXldID09PSByb3dLZXkpIHJldHVybiBkYXRhOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHJldHVybiBkYXRhOwogICAgICAgICAgICB9LAogICAgICAgICAgICBnZXRDaGlsZHJlbkRhdGFCeVJvd0tleSAocm93S2V5LCBjbG9uZURhdGEpIHsKICAgICAgICAgICAgICAgIGxldCBkYXRhID0gbnVsbDsKICAgICAgICAgICAgICAgIGlmIChjbG9uZURhdGEuY2hpbGRyZW4gJiYgY2xvbmVEYXRhLmNoaWxkcmVuLmxlbmd0aCkgewogICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2xvbmVEYXRhLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBjbG9uZURhdGEuY2hpbGRyZW5baV07CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtW3RoaXMucm93S2V5XSA9PT0gcm93S2V5KSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gaXRlbTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW0uY2hpbGRyZW4gJiYgaXRlbS5jaGlsZHJlbi5sZW5ndGgpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLmdldENoaWxkcmVuRGF0YUJ5Um93S2V5KHJvd0tleSwgaXRlbSk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHNlbGVjdEFsbCAoc3RhdHVzKSB7CiAgICAgICAgICAgICAgICAvLyB0aGlzLnJlYnVpbGREYXRhLmZvckVhY2goKGRhdGEpID0+IHsKICAgICAgICAgICAgICAgIC8vICAgICBpZih0aGlzLm9iakRhdGFbZGF0YS5faW5kZXhdLl9pc0Rpc2FibGVkKXsKICAgICAgICAgICAgICAgIC8vICAgICAgICAgdGhpcy5vYmpEYXRhW2RhdGEuX2luZGV4XS5faXNDaGVja2VkID0gZmFsc2U7CiAgICAgICAgICAgICAgICAvLyAgICAgfWVsc2V7CiAgICAgICAgICAgICAgICAvLyAgICAgICAgIHRoaXMub2JqRGF0YVtkYXRhLl9pbmRleF0uX2lzQ2hlY2tlZCA9IHN0YXR1czsKICAgICAgICAgICAgICAgIC8vICAgICB9CgogICAgICAgICAgICAgICAgLy8gfSk7CiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGRhdGEgb2YgdGhpcy5yZWJ1aWxkRGF0YSkgewogICAgICAgICAgICAgICAgICAgIGNvbnN0IG9iakRhdGEgPSB0aGlzLm9iakRhdGFbZGF0YS5faW5kZXhdOwogICAgICAgICAgICAgICAgICAgIGlmICghb2JqRGF0YS5faXNEaXNhYmxlZCkgewogICAgICAgICAgICAgICAgICAgICAgICBvYmpEYXRhLl9pc0NoZWNrZWQgPSBzdGF0dXM7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmNoaWxkcmVuICYmIGRhdGEuY2hpbGRyZW4ubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0QWxsQ2hpbGRyZW4ob2JqRGF0YSwgc3RhdHVzKTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSB0aGlzLmdldFNlbGVjdGlvbigpOwogICAgICAgICAgICAgICAgaWYgKHN0YXR1cykgewogICAgICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ29uLXNlbGVjdC1hbGwnLCBzZWxlY3Rpb24pOwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdvbi1zZWxlY3QtYWxsLWNhbmNlbCcsIHNlbGVjdGlvbik7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdvbi1zZWxlY3Rpb24tY2hhbmdlJywgc2VsZWN0aW9uKTsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgc2VsZWN0QWxsQ2hpbGRyZW4gKGRhdGEsIHN0YXR1cykgewogICAgICAgICAgICAgICAgaWYgKGRhdGEuY2hpbGRyZW4gJiYgZGF0YS5jaGlsZHJlbi5sZW5ndGgpIHsKICAgICAgICAgICAgICAgICAgICBkYXRhLmNoaWxkcmVuLm1hcChpdGVtID0+IHsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpdGVtLl9pc0Rpc2FibGVkKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLl9pc0NoZWNrZWQgPSBzdGF0dXM7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uY2hpbGRyZW4gJiYgaXRlbS5jaGlsZHJlbi5sZW5ndGgpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0QWxsQ2hpbGRyZW4oaXRlbSwgc3RhdHVzKTsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9LAogICAgICAgICAgICBmaXhlZEhlYWRlciAoKSB7CiAgICAgICAgICAgICAgICBpZiAodGhpcy5oZWlnaHQgfHwgdGhpcy5tYXhIZWlnaHQpIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLiRuZXh0VGljaygoKSA9PiB7CiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpdGxlSGVpZ2h0ID0gcGFyc2VJbnQoZ2V0U3R5bGUodGhpcy4kcmVmcy50aXRsZSwgJ2hlaWdodCcpKSB8fCAwOwogICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXJIZWlnaHQgPSBwYXJzZUludChnZXRTdHlsZSh0aGlzLiRyZWZzLmhlYWRlciwgJ2hlaWdodCcpKSB8fCAwOwogICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmb290ZXJIZWlnaHQgPSBwYXJzZUludChnZXRTdHlsZSh0aGlzLiRyZWZzLmZvb3RlciwgJ2hlaWdodCcpKSB8fCAwOwogICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5oZWlnaHQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYm9keUhlaWdodCA9IHRoaXMuaGVpZ2h0IC0gdGl0bGVIZWlnaHQgLSBoZWFkZXJIZWlnaHQgLSBmb290ZXJIZWlnaHQ7CiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5tYXhIZWlnaHQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYm9keUhlaWdodCA9IHRoaXMubWF4SGVpZ2h0IC0gdGl0bGVIZWlnaHQgLSBoZWFkZXJIZWlnaHQgLSBmb290ZXJIZWlnaHQ7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kbmV4dFRpY2soKCk9PnRoaXMuZml4ZWRCb2R5KCkpOwogICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLmJvZHlIZWlnaHQgPSAwOwogICAgICAgICAgICAgICAgICAgIHRoaXMuJG5leHRUaWNrKCgpPT50aGlzLmZpeGVkQm9keSgpKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSwKICAgICAgICAgICAgZml4ZWRCb2R5ICgpewogICAgICAgICAgICAgICAgaWYgKHRoaXMuJHJlZnMuaGVhZGVyKSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5oZWFkZXJXaWR0aCA9IHRoaXMuJHJlZnMuaGVhZGVyLmNoaWxkcmVuWzBdLm9mZnNldFdpZHRoOwogICAgICAgICAgICAgICAgICAgIHRoaXMuaGVhZGVySGVpZ2h0ID0gdGhpcy4kcmVmcy5oZWFkZXIuY2hpbGRyZW5bMF0ub2Zmc2V0SGVpZ2h0OwogICAgICAgICAgICAgICAgICAgIC8vdGhpcy5zaG93SG9yaXpvbnRhbFNjcm9sbEJhciA9IHRoaXMuaGVhZGVyV2lkdGg+dGhpcy4kcmVmcy5oZWFkZXIub2Zmc2V0V2lkdGg7CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgaWYgKCF0aGlzLiRyZWZzLnRib2R5IHx8ICF0aGlzLmRhdGEgfHwgdGhpcy5kYXRhLmxlbmd0aCA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd1ZlcnRpY2FsU2Nyb2xsQmFyID0gZmFsc2U7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBlbHNlewogICAgICAgICAgICAgICAgICAgIGxldCBib2R5Q29udGVudEVsID0gdGhpcy4kcmVmcy50Ym9keS4kZWw7CiAgICAgICAgICAgICAgICAgICAgbGV0IGJvZHlFbCA9IGJvZHlDb250ZW50RWwucGFyZW50RWxlbWVudDsKICAgICAgICAgICAgICAgICAgICBsZXQgYm9keUNvbnRlbnRIZWlnaHQgPSBib2R5Q29udGVudEVsLm9mZnNldEhlaWdodDsKICAgICAgICAgICAgICAgICAgICBsZXQgYm9keUhlaWdodCA9IGJvZHlFbC5vZmZzZXRIZWlnaHQ7CgogICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd0hvcml6b250YWxTY3JvbGxCYXIgPSBib2R5RWwub2Zmc2V0V2lkdGggPCBib2R5Q29udGVudEVsLm9mZnNldFdpZHRoICsgKHRoaXMuc2hvd1ZlcnRpY2FsU2Nyb2xsQmFyP3RoaXMuc2Nyb2xsQmFyV2lkdGg6MCk7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93VmVydGljYWxTY3JvbGxCYXIgPSB0aGlzLmJvZHlIZWlnaHQ/IGJvZHlIZWlnaHQgLSAodGhpcy5zaG93SG9yaXpvbnRhbFNjcm9sbEJhcj90aGlzLnNjcm9sbEJhcldpZHRoOjApIDwgYm9keUNvbnRlbnRIZWlnaHQgOiBmYWxzZTsKCiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5zaG93VmVydGljYWxTY3JvbGxCYXIpewogICAgICAgICAgICAgICAgICAgICAgICBib2R5RWwuY2xhc3NMaXN0LmFkZCh0aGlzLnByZWZpeENscyArJy1vdmVyZmxvd1knKTsKICAgICAgICAgICAgICAgICAgICB9ZWxzZXsKICAgICAgICAgICAgICAgICAgICAgICAgYm9keUVsLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5wcmVmaXhDbHMgKyctb3ZlcmZsb3dZJyk7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuc2hvd0hvcml6b250YWxTY3JvbGxCYXIpewogICAgICAgICAgICAgICAgICAgICAgICBib2R5RWwuY2xhc3NMaXN0LmFkZCh0aGlzLnByZWZpeENscyArJy1vdmVyZmxvd1gnKTsKICAgICAgICAgICAgICAgICAgICB9ZWxzZXsKICAgICAgICAgICAgICAgICAgICAgICAgYm9keUVsLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5wcmVmaXhDbHMgKyctb3ZlcmZsb3dYJyk7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9LAoKICAgICAgICAgICAgaGlkZUNvbHVtbkZpbHRlciAoKSB7CiAgICAgICAgICAgICAgICB0aGlzLmNsb25lQ29sdW1ucy5mb3JFYWNoKChjb2wpID0+IGNvbC5fZmlsdGVyVmlzaWJsZSA9IGZhbHNlKTsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgaGFuZGxlQm9keVNjcm9sbCAoZXZlbnQpIHsKICAgICAgICAgICAgICAgIGlmICh0aGlzLnNob3dIZWFkZXIpIHRoaXMuJHJlZnMuaGVhZGVyLnNjcm9sbExlZnQgPSBldmVudC50YXJnZXQuc2Nyb2xsTGVmdDsKICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzTGVmdEZpeGVkKSB0aGlzLiRyZWZzLmZpeGVkQm9keS5zY3JvbGxUb3AgPSBldmVudC50YXJnZXQuc2Nyb2xsVG9wOwogICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNSaWdodEZpeGVkKSB0aGlzLiRyZWZzLmZpeGVkUmlnaHRCb2R5LnNjcm9sbFRvcCA9IGV2ZW50LnRhcmdldC5zY3JvbGxUb3A7CiAgICAgICAgICAgICAgICBpZiAodGhpcy5zaG93U3VtbWFyeSkgdGhpcy4kcmVmcy5zdW1tYXJ5LiRlbC5zY3JvbGxMZWZ0ID0gZXZlbnQudGFyZ2V0LnNjcm9sbExlZnQ7CiAgICAgICAgICAgICAgICB0aGlzLmhpZGVDb2x1bW5GaWx0ZXIoKTsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgaGFuZGxlRml4ZWRNb3VzZXdoZWVsKGV2ZW50KSB7CiAgICAgICAgICAgICAgICBsZXQgZGVsdGFZID0gZXZlbnQuZGVsdGFZOwogICAgICAgICAgICAgICAgaWYoIWRlbHRhWSAmJiBldmVudC5kZXRhaWwpewogICAgICAgICAgICAgICAgICAgIGRlbHRhWSA9IGV2ZW50LmRldGFpbCAqIDQwOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYoIWRlbHRhWSAmJiBldmVudC53aGVlbERlbHRhWSl7CiAgICAgICAgICAgICAgICAgICAgZGVsdGFZID0gLWV2ZW50LndoZWVsRGVsdGFZOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYoIWRlbHRhWSAmJiBldmVudC53aGVlbERlbHRhKXsKICAgICAgICAgICAgICAgICAgICBkZWx0YVkgPSAtZXZlbnQud2hlZWxEZWx0YTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmKCFkZWx0YVkpIHJldHVybjsKICAgICAgICAgICAgICAgIGNvbnN0IGJvZHkgPSB0aGlzLiRyZWZzLmJvZHk7CiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50U2Nyb2xsVG9wID0gYm9keS5zY3JvbGxUb3A7CiAgICAgICAgICAgICAgICBpZiAoZGVsdGFZIDwgMCAmJiBjdXJyZW50U2Nyb2xsVG9wICE9PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChkZWx0YVkgPiAwICYmIGJvZHkuc2Nyb2xsSGVpZ2h0IC0gYm9keS5jbGllbnRIZWlnaHQgPiBjdXJyZW50U2Nyb2xsVG9wKSB7CiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIC8vYm9keS5zY3JvbGxUb3AgKz0gZGVsdGFZOwogICAgICAgICAgICAgICAgbGV0IHN0ZXAgPSAwOwogICAgICAgICAgICAgICAgbGV0IHRpbWVJZCA9IHNldEludGVydmFsKCgpPT57CiAgICAgICAgICAgICAgICAgICAgc3RlcCArPSA1OwogICAgICAgICAgICAgICAgICAgIGlmKGRlbHRhWT4wKXsKICAgICAgICAgICAgICAgICAgICAgICAgYm9keS5zY3JvbGxUb3AgKz0gMjsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgZWxzZXsKICAgICAgICAgICAgICAgICAgICAgICAgYm9keS5zY3JvbGxUb3AgLT0gMjsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaWYoc3RlcCA+PSBNYXRoLmFicyhkZWx0YVkpKXsKICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aW1lSWQpOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0sIDUpOwogICAgICAgICAgICB9LAogICAgICAgICAgICBoYW5kbGVNb3VzZVdoZWVsIChldmVudCkgewogICAgICAgICAgICAgICAgY29uc3QgZGVsdGFYID0gZXZlbnQuZGVsdGFYOwogICAgICAgICAgICAgICAgY29uc3QgJGJvZHkgPSB0aGlzLiRyZWZzLmJvZHk7CgogICAgICAgICAgICAgICAgaWYgKGRlbHRhWCA+IDApIHsKICAgICAgICAgICAgICAgICAgICAkYm9keS5zY3JvbGxMZWZ0ID0gJGJvZHkuc2Nyb2xsTGVmdCArIDEwOwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAkYm9keS5zY3JvbGxMZWZ0ID0gJGJvZHkuc2Nyb2xsTGVmdCAtIDEwOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9LAogICAgICAgICAgICBzb3J0RGF0YSAoZGF0YSwgdHlwZSwgaW5kZXgpIHsKICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IHRoaXMuY2xvbmVDb2x1bW5zW2luZGV4XS5rZXk7CiAgICAgICAgICAgICAgICBkYXRhLnNvcnQoKGEsIGIpID0+IHsKICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jbG9uZUNvbHVtbnNbaW5kZXhdLnNvcnRNZXRob2QpIHsKICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmVDb2x1bW5zW2luZGV4XS5zb3J0TWV0aG9kKGFba2V5XSwgYltrZXldLCB0eXBlKTsKICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2FzYycpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhW2tleV0gPiBiW2tleV0gPyAxIDogLTE7CiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Rlc2MnKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYVtrZXldIDwgYltrZXldID8gMSA6IC0xOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVtpXS5jaGlsZHJlbiAmJiBkYXRhW2ldLmNoaWxkcmVuLmxlbmd0aCkgewogICAgICAgICAgICAgICAgICAgICAgICBkYXRhW2ldLmNoaWxkcmVuID0gdGhpcy5zb3J0RGF0YShkYXRhW2ldLmNoaWxkcmVuLCB0eXBlLCBpbmRleCk7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGhhbmRsZVNvcnQgKF9pbmRleCwgdHlwZSkgewogICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLkdldE9yaWdpbmFsSW5kZXgoX2luZGV4KTsKICAgICAgICAgICAgICAgIHRoaXMuY2xvbmVDb2x1bW5zLmZvckVhY2goKGNvbCkgPT4gY29sLl9zb3J0VHlwZSA9ICdub3JtYWwnKTsKCiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmNsb25lQ29sdW1uc1tpbmRleF0ua2V5OwogICAgICAgICAgICAgICAgaWYgKHRoaXMuY2xvbmVDb2x1bW5zW2luZGV4XS5zb3J0YWJsZSAhPT0gJ2N1c3RvbScpIHsgICAgLy8gY3VzdG9tIGlzIGZvciByZW1vdGUgc29ydAogICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnbm9ybWFsJykgewogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYnVpbGREYXRhID0gdGhpcy5tYWtlRGF0YVdpdGhGaWx0ZXIoKTsKICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYnVpbGREYXRhID0gdGhpcy5zb3J0RGF0YSh0aGlzLnJlYnVpbGREYXRhLCB0eXBlLCBpbmRleCk7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgdGhpcy5jbG9uZUNvbHVtbnNbaW5kZXhdLl9zb3J0VHlwZSA9IHR5cGU7CgogICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnb24tc29ydC1jaGFuZ2UnLCB7CiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMuYWxsQ29sdW1uc1t0aGlzLmNsb25lQ29sdW1uc1tpbmRleF0uX2luZGV4XSkpLAogICAgICAgICAgICAgICAgICAgIGtleToga2V5LAogICAgICAgICAgICAgICAgICAgIG9yZGVyOiB0eXBlCiAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgaGFuZGxlRmlsdGVySGlkZSAoaW5kZXgpIHsgICAgLy8gY2xlYXIgY2hlY2tlZCB0aGF0IG5vdCBmaWx0ZXIgbm93CiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY2xvbmVDb2x1bW5zW2luZGV4XS5faXNGaWx0ZXJlZCkgdGhpcy5jbG9uZUNvbHVtbnNbaW5kZXhdLl9maWx0ZXJDaGVja2VkID0gW107CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGZpbHRlckRhdGEgKGRhdGEsIGNvbHVtbikgewogICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEuZmlsdGVyKChyb3cpID0+IHsKICAgICAgICAgICAgICAgICAgICAvL+WmguaenOWumuS5ieS6hui/nOeoi+i/h+a7pOaWueazleWImeW/veeVpeatpOaWueazlQogICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29sdW1uLmZpbHRlclJlbW90ZSA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHRydWU7CgogICAgICAgICAgICAgICAgICAgIGxldCBzdGF0dXMgPSAhY29sdW1uLl9maWx0ZXJDaGVja2VkLmxlbmd0aDsKICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHVtbi5fZmlsdGVyQ2hlY2tlZC5sZW5ndGg7IGkrKykgewogICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMgPSBjb2x1bW4uZmlsdGVyTWV0aG9kKGNvbHVtbi5fZmlsdGVyQ2hlY2tlZFtpXSwgcm93KTsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cykgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0dXM7CiAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgZmlsdGVyT3RoZXJEYXRhIChkYXRhLCBpbmRleCkgewogICAgICAgICAgICAgICAgbGV0IGNvbHVtbiA9IHRoaXMuY2xvbmVDb2x1bW5zW2luZGV4XTsKICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29sdW1uLmZpbHRlclJlbW90ZSA9PT0gJ2Z1bmN0aW9uJykgewogICAgICAgICAgICAgICAgICAgIGNvbHVtbi5maWx0ZXJSZW1vdGUuY2FsbCh0aGlzLiRwYXJlbnQsIGNvbHVtbi5fZmlsdGVyQ2hlY2tlZCwgY29sdW1uLmtleSwgY29sdW1uKTsKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICB0aGlzLmNsb25lQ29sdW1ucy5mb3JFYWNoKChjb2wsIGNvbEluZGV4KSA9PiB7CiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbEluZGV4ICE9PSBpbmRleCkgewogICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gdGhpcy5maWx0ZXJEYXRhKGRhdGEsIGNvbCk7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgaGFuZGxlRmlsdGVyIChpbmRleCkgewogICAgICAgICAgICAgICAgY29uc3QgY29sdW1uID0gdGhpcy5jbG9uZUNvbHVtbnNbaW5kZXhdOwogICAgICAgICAgICAgICAgbGV0IGZpbHRlckRhdGEgPSB0aGlzLm1ha2VEYXRhV2l0aFNvcnQoKTsKCiAgICAgICAgICAgICAgICAvLyBmaWx0ZXIgb3RoZXJzIGZpcnN0LCBhZnRlciBmaWx0ZXIgdGhpcyBjb2x1bW4KICAgICAgICAgICAgICAgIGZpbHRlckRhdGEgPSB0aGlzLmZpbHRlck90aGVyRGF0YShmaWx0ZXJEYXRhLCBpbmRleCk7CiAgICAgICAgICAgICAgICB0aGlzLnJlYnVpbGREYXRhID0gdGhpcy5maWx0ZXJEYXRhKGZpbHRlckRhdGEsIGNvbHVtbik7CgogICAgICAgICAgICAgICAgdGhpcy5jbG9uZUNvbHVtbnNbaW5kZXhdLl9pc0ZpbHRlcmVkID0gdHJ1ZTsKICAgICAgICAgICAgICAgIHRoaXMuY2xvbmVDb2x1bW5zW2luZGV4XS5fZmlsdGVyVmlzaWJsZSA9IGZhbHNlOwogICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnb24tZmlsdGVyLWNoYW5nZScsIGNvbHVtbik7CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIC8qKgogICAgICAgICAgICAgKiAjMjgzMgogICAgICAgICAgICAgKiDlupTor6XljLrliIblvZPliY3ooajlpLTnmoQgY29sdW1uIOaYr+W3puWbuuWumui/mOaYr+WPs+WbuuWumgogICAgICAgICAgICAgKiDlkKbliJnmiafooYzliLAgJHBhcmVudCDml7bvvIzmlrnms5XnmoQgaW5kZXgg5LiOIGNsb25lQ29sdW1ucyDnmoQgaW5kZXgg5piv5LiN5a+55bqU55qECiAgICAgICAgICAgICAqIOW3puWbuuWumuWSjOWPs+WbuuWumu+8jOimgeWMuuWIhuWvueW+hQogICAgICAgICAgICAgKiDmiYDku6XvvIzmraTmlrnms5XnlKjmnaXojrflj5bmraPnoa7nmoQgaW5kZXgKICAgICAgICAgICAgICogKi8KICAgICAgICAgICAgR2V0T3JpZ2luYWxJbmRleCAoX2luZGV4KSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9uZUNvbHVtbnMuZmluZEluZGV4KGl0ZW0gPT4gaXRlbS5faW5kZXggPT09IF9pbmRleCk7CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGhhbmRsZUZpbHRlclNlbGVjdCAoX2luZGV4LCB2YWx1ZSkgewogICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLkdldE9yaWdpbmFsSW5kZXgoX2luZGV4KTsKICAgICAgICAgICAgICAgIHRoaXMuY2xvbmVDb2x1bW5zW2luZGV4XS5fZmlsdGVyQ2hlY2tlZCA9IFt2YWx1ZV07CiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUZpbHRlcihpbmRleCk7CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGhhbmRsZUZpbHRlclJlc2V0IChfaW5kZXgpIHsKICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5HZXRPcmlnaW5hbEluZGV4KF9pbmRleCk7CiAgICAgICAgICAgICAgICB0aGlzLmNsb25lQ29sdW1uc1tpbmRleF0uX2lzRmlsdGVyZWQgPSBmYWxzZTsKICAgICAgICAgICAgICAgIHRoaXMuY2xvbmVDb2x1bW5zW2luZGV4XS5fZmlsdGVyVmlzaWJsZSA9IGZhbHNlOwogICAgICAgICAgICAgICAgdGhpcy5jbG9uZUNvbHVtbnNbaW5kZXhdLl9maWx0ZXJDaGVja2VkID0gW107CgogICAgICAgICAgICAgICAgbGV0IGZpbHRlckRhdGEgPSB0aGlzLm1ha2VEYXRhV2l0aFNvcnQoKTsKICAgICAgICAgICAgICAgIGZpbHRlckRhdGEgPSB0aGlzLmZpbHRlck90aGVyRGF0YShmaWx0ZXJEYXRhLCBpbmRleCk7CiAgICAgICAgICAgICAgICB0aGlzLnJlYnVpbGREYXRhID0gZmlsdGVyRGF0YTsKICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ29uLWZpbHRlci1jaGFuZ2UnLCB0aGlzLmNsb25lQ29sdW1uc1tpbmRleF0pOwogICAgICAgICAgICB9LAogICAgICAgICAgICBtYWtlRGF0YSAoKSB7CiAgICAgICAgICAgICAgICBsZXQgZGF0YSA9IGRlZXBDb3B5KHRoaXMuZGF0YSk7CiAgICAgICAgICAgICAgICBkYXRhLmZvckVhY2goKHJvdywgaW5kZXgpID0+IHsKICAgICAgICAgICAgICAgICAgICByb3cuX2luZGV4ID0gaW5kZXg7CiAgICAgICAgICAgICAgICAgICAgcm93Ll9yb3dLZXkgPSAodHlwZW9mIHRoaXMucm93S2V5KSA9PT0gJ3N0cmluZycgPyByb3dbdGhpcy5yb3dLZXldIDogcm93S2V5Kys7CiAgICAgICAgICAgICAgICAgICAgaWYgKHJvdy5jaGlsZHJlbiAmJiByb3cuY2hpbGRyZW4ubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHJvdy5jaGlsZHJlbiA9IHRoaXMubWFrZUNoaWxkcmVuRGF0YShyb3cpOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIG1ha2VDaGlsZHJlbkRhdGEgKGRhdGEpIHsKICAgICAgICAgICAgICAgIGlmIChkYXRhLmNoaWxkcmVuICYmIGRhdGEuY2hpbGRyZW4ubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEuY2hpbGRyZW4ubWFwKChyb3csIGluZGV4KSA9PiB7CiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1JvdyA9IGRlZXBDb3B5KHJvdyk7CiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Jvdy5faW5kZXggPSBpbmRleDsKICAgICAgICAgICAgICAgICAgICAgICAgbmV3Um93Ll9yb3dLZXkgPSAodHlwZW9mIHRoaXMucm93S2V5KSA9PT0gJ3N0cmluZycgPyBuZXdSb3dbdGhpcy5yb3dLZXldIDogcm93S2V5Kys7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdSb3cuY2hpbGRyZW4gJiYgbmV3Um93LmNoaWxkcmVuLmxlbmd0aCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Um93LmNoaWxkcmVuID0gdGhpcy5tYWtlQ2hpbGRyZW5EYXRhKG5ld1Jvdyk7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld1JvdzsKICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIG1ha2VEYXRhV2l0aFNvcnQgKCkgewogICAgICAgICAgICAgICAgbGV0IGRhdGEgPSB0aGlzLm1ha2VEYXRhKCk7CiAgICAgICAgICAgICAgICBsZXQgc29ydFR5cGUgPSAnbm9ybWFsJzsKICAgICAgICAgICAgICAgIGxldCBzb3J0SW5kZXggPSAtMTsKICAgICAgICAgICAgICAgIGxldCBpc0N1c3RvbSA9IGZhbHNlOwoKICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jbG9uZUNvbHVtbnMubGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jbG9uZUNvbHVtbnNbaV0uX3NvcnRUeXBlICE9PSAnbm9ybWFsJykgewogICAgICAgICAgICAgICAgICAgICAgICBzb3J0VHlwZSA9IHRoaXMuY2xvbmVDb2x1bW5zW2ldLl9zb3J0VHlwZTsKICAgICAgICAgICAgICAgICAgICAgICAgc29ydEluZGV4ID0gaTsKICAgICAgICAgICAgICAgICAgICAgICAgaXNDdXN0b20gPSB0aGlzLmNsb25lQ29sdW1uc1tpXS5zb3J0YWJsZSA9PT0gJ2N1c3RvbSc7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChzb3J0VHlwZSAhPT0gJ25vcm1hbCcgJiYgIWlzQ3VzdG9tKSBkYXRhID0gIHRoaXMuc29ydERhdGEoZGF0YSwgc29ydFR5cGUsIHNvcnRJbmRleCk7CiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgbWFrZURhdGFXaXRoRmlsdGVyICgpIHsKICAgICAgICAgICAgICAgIGxldCBkYXRhID0gdGhpcy5tYWtlRGF0YSgpOwogICAgICAgICAgICAgICAgdGhpcy5jbG9uZUNvbHVtbnMuZm9yRWFjaChjb2wgPT4gZGF0YSA9IHRoaXMuZmlsdGVyRGF0YShkYXRhLCBjb2wpKTsKICAgICAgICAgICAgICAgIHJldHVybiBkYXRhOwogICAgICAgICAgICB9LAogICAgICAgICAgICBtYWtlRGF0YVdpdGhTb3J0QW5kRmlsdGVyICgpIHsKICAgICAgICAgICAgICAgIGxldCBkYXRhID0gdGhpcy5tYWtlRGF0YVdpdGhTb3J0KCk7CiAgICAgICAgICAgICAgICB0aGlzLmNsb25lQ29sdW1ucy5mb3JFYWNoKGNvbCA9PiBkYXRhID0gdGhpcy5maWx0ZXJEYXRhKGRhdGEsIGNvbCkpOwogICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIG1ha2VPYmpCYXNlRGF0YSAocm93KSB7CiAgICAgICAgICAgICAgICBjb25zdCBuZXdSb3cgPSBkZWVwQ29weShyb3cpOwogICAgICAgICAgICAgICAgaWYgKCh0eXBlb2YgdGhpcy5yb3dLZXkpID09PSAnc3RyaW5nJykgewogICAgICAgICAgICAgICAgICAgIG5ld1Jvdy5fcm93S2V5ID0gbmV3Um93W3RoaXMucm93S2V5XTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIG5ld1Jvdy5faXNIb3ZlciA9IGZhbHNlOwogICAgICAgICAgICAgICAgaWYgKG5ld1Jvdy5fZGlzYWJsZWQpIHsKICAgICAgICAgICAgICAgICAgICBuZXdSb3cuX2lzRGlzYWJsZWQgPSBuZXdSb3cuX2Rpc2FibGVkOwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICBuZXdSb3cuX2lzRGlzYWJsZWQgPSBmYWxzZTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChuZXdSb3cuX2NoZWNrZWQpIHsKICAgICAgICAgICAgICAgICAgICBuZXdSb3cuX2lzQ2hlY2tlZCA9IG5ld1Jvdy5fY2hlY2tlZDsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgbmV3Um93Ll9pc0NoZWNrZWQgPSBmYWxzZTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChuZXdSb3cuX2V4cGFuZGVkKSB7CiAgICAgICAgICAgICAgICAgICAgbmV3Um93Ll9pc0V4cGFuZGVkID0gbmV3Um93Ll9leHBhbmRlZDsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgbmV3Um93Ll9pc0V4cGFuZGVkID0gZmFsc2U7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAobmV3Um93Ll9oaWdobGlnaHQpIHsKICAgICAgICAgICAgICAgICAgICBuZXdSb3cuX2lzSGlnaGxpZ2h0ID0gbmV3Um93Ll9oaWdobGlnaHQ7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIG5ld1Jvdy5faXNIaWdobGlnaHQgPSBmYWxzZTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHJldHVybiBuZXdSb3c7CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIG1ha2VPYmpEYXRhICgpIHsKICAgICAgICAgICAgICAgIGxldCBkYXRhID0ge307CiAgICAgICAgICAgICAgICB0aGlzLmRhdGEuZm9yRWFjaCgocm93LCBpbmRleCkgPT4gewogICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1JvdyA9IHRoaXMubWFrZU9iakJhc2VEYXRhKHJvdyk7CiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1Jvdy5jaGlsZHJlbiAmJiBuZXdSb3cuY2hpbGRyZW4ubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdSb3cuX3Nob3dDaGlsZHJlbikgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Um93Ll9pc1Nob3dDaGlsZHJlbiA9IG5ld1Jvdy5fc2hvd0NoaWxkcmVuOwogICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Um93Ll9pc1Nob3dDaGlsZHJlbiA9IGZhbHNlOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Jvdy5jaGlsZHJlbiA9IHRoaXMubWFrZUNoaWxkcmVuT2JqRGF0YShuZXdSb3cpOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAvLyBlbHNlIGlmICgnX2xvYWRpbmcnIGluIG5ld1JvdyAmJiBuZXdSb3cuY2hpbGRyZW4gJiYgbmV3Um93LmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIC8vICAgICBuZXdSb3cuX2lzU2hvd0NoaWxkcmVuID0gZmFsc2U7CiAgICAgICAgICAgICAgICAgICAgLy8gfQogICAgICAgICAgICAgICAgICAgIGRhdGFbaW5kZXhdID0gbmV3Um93OwogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgbWFrZUNoaWxkcmVuT2JqRGF0YSAoZGF0YSkgewogICAgICAgICAgICAgICAgaWYgKGRhdGEuY2hpbGRyZW4gJiYgZGF0YS5jaGlsZHJlbi5sZW5ndGgpIHsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5jaGlsZHJlbi5tYXAocm93ID0+IHsKICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3Um93ID0gdGhpcy5tYWtlT2JqQmFzZURhdGEocm93KTsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1Jvdy5fc2hvd0NoaWxkcmVuKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdSb3cuX2lzU2hvd0NoaWxkcmVuID0gbmV3Um93Ll9zaG93Q2hpbGRyZW47CiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdSb3cuX2lzU2hvd0NoaWxkcmVuID0gZmFsc2U7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1Jvdy5jaGlsZHJlbiAmJiBuZXdSb3cuY2hpbGRyZW4ubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdSb3cuY2hpbGRyZW4gPSB0aGlzLm1ha2VDaGlsZHJlbk9iakRhdGEobmV3Um93KTsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3Um93OwogICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSwKICAgICAgICAgICAgLy8g5L+u5pS55YiX77yM6K6+572u5LiA5Liq6ZqQ6JeP55qEIGlk77yM5L6/5LqO5ZCO6Z2i55qE5aSa57qn6KGo5aS05a+75om+5a+55bqU55qE5YiX77yM5ZCm5YiZ5om+5LiN5YiwCiAgICAgICAgICAgIG1ha2VDb2x1bW5zSWQgKGNvbHVtbnMpIHsKICAgICAgICAgICAgICAgIHJldHVybiBjb2x1bW5zLm1hcChpdGVtID0+IHsKICAgICAgICAgICAgICAgICAgICBpZiAoJ2NoaWxkcmVuJyBpbiBpdGVtKSB0aGlzLm1ha2VDb2x1bW5zSWQoaXRlbS5jaGlsZHJlbik7CiAgICAgICAgICAgICAgICAgICAgaXRlbS5fX2lkID0gZ2V0UmFuZG9tU3RyKDYpOwogICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtOwogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIG1ha2VDb2x1bW5zIChjb2xzKSB7CiAgICAgICAgICAgICAgICAvLyDlnKggZGF0YSDml7bvvIx0aGlzLmFsbENvbHVtbnMg5pqC5pe25Li6IHVuZGVmaW5lZAogICAgICAgICAgICAgICAgbGV0IGNvbHVtbnMgPSBkZWVwQ29weShnZXRBbGxDb2x1bW5zKGNvbHMpKTsKICAgICAgICAgICAgICAgIGxldCBsZWZ0ID0gW107CiAgICAgICAgICAgICAgICBsZXQgcmlnaHQgPSBbXTsKICAgICAgICAgICAgICAgIGxldCBjZW50ZXIgPSBbXTsKCiAgICAgICAgICAgICAgICBjb2x1bW5zLmZvckVhY2goKGNvbHVtbiwgaW5kZXgpID0+IHsKICAgICAgICAgICAgICAgICAgICBjb2x1bW4uX2luZGV4ID0gaW5kZXg7CiAgICAgICAgICAgICAgICAgICAgY29sdW1uLl9jb2x1bW5LZXkgPSBjb2x1bW5LZXkrKzsKICAgICAgICAgICAgICAgICAgICBjb2x1bW4ud2lkdGggPSBwYXJzZUludChjb2x1bW4ud2lkdGgpOwogICAgICAgICAgICAgICAgICAgIGNvbHVtbi5fd2lkdGggPSBjb2x1bW4ud2lkdGggPyBjb2x1bW4ud2lkdGggOiAnJzsgICAgLy8gdXBkYXRlIGluIGhhbmRsZVJlc2l6ZSgpCiAgICAgICAgICAgICAgICAgICAgY29sdW1uLl9zb3J0VHlwZSA9ICdub3JtYWwnOwogICAgICAgICAgICAgICAgICAgIGNvbHVtbi5fZmlsdGVyVmlzaWJsZSA9IGZhbHNlOwogICAgICAgICAgICAgICAgICAgIGNvbHVtbi5faXNGaWx0ZXJlZCA9IGZhbHNlOwogICAgICAgICAgICAgICAgICAgIGNvbHVtbi5fZmlsdGVyQ2hlY2tlZCA9IFtdOwoKICAgICAgICAgICAgICAgICAgICBpZiAoJ2ZpbHRlck11bHRpcGxlJyBpbiBjb2x1bW4pIHsKICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uLl9maWx0ZXJNdWx0aXBsZSA9IGNvbHVtbi5maWx0ZXJNdWx0aXBsZTsKICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW4uX2ZpbHRlck11bHRpcGxlID0gdHJ1ZTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaWYgKCdmaWx0ZXJlZFZhbHVlJyBpbiBjb2x1bW4pIHsKICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uLl9maWx0ZXJDaGVja2VkID0gY29sdW1uLmZpbHRlcmVkVmFsdWU7CiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbi5faXNGaWx0ZXJlZCA9IHRydWU7CiAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICBpZiAoJ3NvcnRUeXBlJyBpbiBjb2x1bW4pIHsKICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uLl9zb3J0VHlwZSA9IGNvbHVtbi5zb3J0VHlwZTsKICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgIGlmIChjb2x1bW4uZml4ZWQgJiYgY29sdW1uLmZpeGVkID09PSAnbGVmdCcpIHsKICAgICAgICAgICAgICAgICAgICAgICAgbGVmdC5wdXNoKGNvbHVtbik7CiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2x1bW4uZml4ZWQgJiYgY29sdW1uLmZpeGVkID09PSAncmlnaHQnKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0LnB1c2goY29sdW1uKTsKICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICBjZW50ZXIucHVzaChjb2x1bW4pOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQuY29uY2F0KGNlbnRlcikuY29uY2F0KHJpZ2h0KTsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgLy8gY3JlYXRlIGEgbXVsdGlwbGUgdGFibGUtaGVhZAogICAgICAgICAgICBtYWtlQ29sdW1uUm93cyAoZml4ZWRUeXBlLCBjb2xzKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gY29udmVydFRvUm93cyhjb2xzLCBmaXhlZFR5cGUpOwogICAgICAgICAgICB9LAogICAgICAgICAgICBleHBvcnRDc3YgKHBhcmFtcykgewogICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5maWxlbmFtZSkgewogICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuZmlsZW5hbWUuaW5kZXhPZignLmNzdicpID09PSAtMSkgewogICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMuZmlsZW5hbWUgKz0gJy5jc3YnOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmZpbGVuYW1lID0gJ3RhYmxlLmNzdic7CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgbGV0IGNvbHVtbnMgPSBbXTsKICAgICAgICAgICAgICAgIGxldCBkYXRhcyA9IFtdOwogICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5jb2x1bW5zICYmIHBhcmFtcy5kYXRhKSB7CiAgICAgICAgICAgICAgICAgICAgY29sdW1ucyA9IHBhcmFtcy5jb2x1bW5zOwogICAgICAgICAgICAgICAgICAgIGRhdGFzID0gcGFyYW1zLmRhdGE7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIGNvbHVtbnMgPSB0aGlzLmFsbENvbHVtbnM7CiAgICAgICAgICAgICAgICAgICAgaWYgKCEoJ29yaWdpbmFsJyBpbiBwYXJhbXMpKSBwYXJhbXMub3JpZ2luYWwgPSB0cnVlOwogICAgICAgICAgICAgICAgICAgIGRhdGFzID0gcGFyYW1zLm9yaWdpbmFsID8gdGhpcy5kYXRhIDogdGhpcy5yZWJ1aWxkRGF0YTsKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICBsZXQgbm9IZWFkZXIgPSBmYWxzZTsKICAgICAgICAgICAgICAgIGlmICgnbm9IZWFkZXInIGluIHBhcmFtcykgbm9IZWFkZXIgPSBwYXJhbXMubm9IZWFkZXI7CgogICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IENzdihjb2x1bW5zLCBkYXRhcywgcGFyYW1zLCBub0hlYWRlcik7CiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmNhbGxiYWNrKSBwYXJhbXMuY2FsbGJhY2soZGF0YSk7CiAgICAgICAgICAgICAgICBlbHNlIEV4cG9ydENzdi5kb3dubG9hZChwYXJhbXMuZmlsZW5hbWUsIGRhdGEpOwogICAgICAgICAgICB9LAogICAgICAgICAgICBkcmFnQW5kRHJvcChhLGIpIHsKICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ29uLWRyYWctZHJvcCcsIGEsYik7CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGhhbmRsZUNsaWNrQ29udGV4dE1lbnVPdXRzaWRlIChldmVudCkgewogICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0TWVudVZpc2libGUgPSBmYWxzZTsKICAgICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgY3JlYXRlZCAoKSB7CiAgICAgICAgICAgIGlmICghdGhpcy5jb250ZXh0KSB0aGlzLmN1cnJlbnRDb250ZXh0ID0gdGhpcy4kcGFyZW50OwogICAgICAgICAgICB0aGlzLnNob3dTbG90SGVhZGVyID0gdGhpcy4kc2xvdHMuaGVhZGVyICE9PSB1bmRlZmluZWQ7CiAgICAgICAgICAgIHRoaXMuc2hvd1Nsb3RGb290ZXIgPSB0aGlzLiRzbG90cy5mb290ZXIgIT09IHVuZGVmaW5lZDsKICAgICAgICAgICAgdGhpcy5yZWJ1aWxkRGF0YSA9IHRoaXMubWFrZURhdGFXaXRoU29ydEFuZEZpbHRlcigpOwogICAgICAgIH0sCiAgICAgICAgbW91bnRlZCAoKSB7CiAgICAgICAgICAgIHRoaXMuaGFuZGxlUmVzaXplKCk7CiAgICAgICAgICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHRoaXMucmVhZHkgPSB0cnVlKTsKCiAgICAgICAgICAgIG9uKHdpbmRvdywgJ3Jlc2l6ZScsIHRoaXMuaGFuZGxlUmVzaXplKTsKICAgICAgICAgICAgdGhpcy5vYnNlcnZlciA9IGVsZW1lbnRSZXNpemVEZXRlY3Rvck1ha2VyKCk7CiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIubGlzdGVuVG8odGhpcy4kZWwsIHRoaXMuaGFuZGxlUmVzaXplKTsKCiAgICAgICAgICAgIHRoaXMuJG9uKCdvbi12aXNpYmxlLWNoYW5nZScsICh2YWwpID0+IHsKICAgICAgICAgICAgICAgIGlmICh2YWwpIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLiRuZXh0VGljaygoKSA9PiB7CiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUmVzaXplKCk7CiAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0pOwogICAgICAgIH0sCiAgICAgICAgYmVmb3JlRGVzdHJveSAoKSB7CiAgICAgICAgICAgIG9mZih3aW5kb3csICdyZXNpemUnLCB0aGlzLmhhbmRsZVJlc2l6ZSk7CiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIucmVtb3ZlTGlzdGVuZXIodGhpcy4kZWwsIHRoaXMuaGFuZGxlUmVzaXplKTsKICAgICAgICB9LAogICAgICAgIHdhdGNoOiB7CiAgICAgICAgICAgIGRhdGE6IHsKICAgICAgICAgICAgICAgIGhhbmRsZXIgKCkgewogICAgICAgICAgICAgICAgICAgIGNvbnN0IG9sZERhdGFMZW4gPSB0aGlzLnJlYnVpbGREYXRhLmxlbmd0aDsKICAgICAgICAgICAgICAgICAgICB0aGlzLm9iakRhdGEgPSB0aGlzLm1ha2VPYmpEYXRhKCk7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWJ1aWxkRGF0YSA9IHRoaXMubWFrZURhdGFXaXRoU29ydEFuZEZpbHRlcigpOwogICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUmVzaXplKCk7CiAgICAgICAgICAgICAgICAgICAgaWYgKCFvbGREYXRhTGVuKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZml4ZWRIZWFkZXIoKTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgLy8gaGVyZSB3aWxsIHRyaWdnZXIgYmVmb3JlIGNsaWNrQ3VycmVudFJvdywgc28gdXNlIGFzeW5jCiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7CiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvbmVEYXRhID0gZGVlcENvcHkodGhpcy5kYXRhKTsKICAgICAgICAgICAgICAgICAgICB9LCAwKTsKICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICBkZWVwOiB0cnVlCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGNvbHVtbnM6IHsKICAgICAgICAgICAgICAgIGhhbmRsZXIgKCkgewogICAgICAgICAgICAgICAgICAgIC8vIHRvZG8g6L+Z6YeM5pyJ5oCn6IO96Zeu6aKY77yM5Y+v6IO95piv5bem5Y+z5Zu65a6a6K6h566X5bGe5oCn5b2x5ZON55qECiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29sc1dpdGhJZCA9IHRoaXMubWFrZUNvbHVtbnNJZCh0aGlzLmNvbHVtbnMpOwogICAgICAgICAgICAgICAgICAgIHRoaXMuYWxsQ29sdW1ucyA9IGdldEFsbENvbHVtbnMoY29sc1dpdGhJZCk7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9uZUNvbHVtbnMgPSB0aGlzLm1ha2VDb2x1bW5zKGNvbHNXaXRoSWQpOwoKICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbHVtblJvd3MgPSB0aGlzLm1ha2VDb2x1bW5Sb3dzKGZhbHNlLCBjb2xzV2l0aElkKTsKICAgICAgICAgICAgICAgICAgICB0aGlzLmxlZnRGaXhlZENvbHVtblJvd3MgPSB0aGlzLm1ha2VDb2x1bW5Sb3dzKCdsZWZ0JywgY29sc1dpdGhJZCk7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5yaWdodEZpeGVkQ29sdW1uUm93cyA9IHRoaXMubWFrZUNvbHVtblJvd3MoJ3JpZ2h0JywgY29sc1dpdGhJZCk7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWJ1aWxkRGF0YSA9IHRoaXMubWFrZURhdGFXaXRoU29ydEFuZEZpbHRlcigpOwogICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUmVzaXplKCk7CiAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgZGVlcDogdHJ1ZQogICAgICAgICAgICB9LAogICAgICAgICAgICBoZWlnaHQgKCkgewogICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVSZXNpemUoKTsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgbWF4SGVpZ2h0ICgpIHsKICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUmVzaXplKCk7CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHNob3dIb3Jpem9udGFsU2Nyb2xsQmFyICgpIHsKICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUmVzaXplKCk7CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHNob3dWZXJ0aWNhbFNjcm9sbEJhciAoKSB7CiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVJlc2l6ZSgpOwogICAgICAgICAgICB9CiAgICAgICAgfQogICAgfTsK"},{"version":3,"sources":["table.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"table.vue","sourceRoot":"node_modules/view-design/src/components/table","sourcesContent":["<template>\n    <div :class=\"wrapClasses\" :style=\"styles\" ref=\"tableWrap\">\n        <div :class=\"classes\">\n            <div :class=\"[prefixCls + '-title']\" v-if=\"showSlotHeader\" ref=\"title\"><slot name=\"header\"></slot></div>\n            <div :class=\"[prefixCls + '-header']\" v-if=\"showHeader\" ref=\"header\" @mousewheel=\"handleMouseWheel\">\n                <table-head\n                    :prefix-cls=\"prefixCls\"\n                    :styleObject=\"tableHeaderStyle\"\n                    :columns=\"cloneColumns\"\n                    :column-rows=\"columnRows\"\n                    :obj-data=\"objData\"\n                    :columns-width=\"columnsWidth\"\n                    :data=\"rebuildData\"></table-head>\n            </div>\n            <div :class=\"[prefixCls + '-body']\" :style=\"bodyStyle\" ref=\"body\" @scroll=\"handleBodyScroll\"\n                v-show=\"!((!!localeNoDataText && (!data || data.length === 0)) || (!!localeNoFilteredDataText && (!rebuildData || rebuildData.length === 0)))\">\n                <table-body\n                    ref=\"tbody\"\n                    :draggable=\"draggable\"\n                    :prefix-cls=\"prefixCls\"\n                    :styleObject=\"tableStyle\"\n                    :columns=\"cloneColumns\"\n                    :data=\"rebuildData\"\n                    :row-key=\"rowKey\"\n                    :columns-width=\"columnsWidth\"\n                    :obj-data=\"objData\"></table-body>\n            </div>\n            <table-summary\n                v-if=\"showSummary && (data && data.length)\"\n                ref=\"summary\"\n                :prefix-cls=\"prefixCls\"\n                :styleObject=\"tableStyle\"\n                :columns=\"cloneColumns\"\n                :data=\"summaryData\"\n                :columns-width=\"columnsWidth\"\n            />\n            <div\n                :class=\"[prefixCls + '-tip']\" :style=\"bodyStyle\" @scroll=\"handleBodyScroll\"\n                v-show=\"((!!localeNoDataText && (!data || data.length === 0)) || (!!localeNoFilteredDataText && (!rebuildData || rebuildData.length === 0)))\">\n                <table cellspacing=\"0\" cellpadding=\"0\" border=\"0\">\n                    <tbody>\n                        <tr>\n                            <td :style=\"{'height':bodyStyle.height,'width':`${this.headerWidth}px`}\">\n                                <span v-html=\"localeNoDataText\" v-if=\"!data || data.length === 0\"></span>\n                                <span v-html=\"localeNoFilteredDataText\" v-else></span>\n                            </td>\n                        </tr>\n                    </tbody>\n                </table>\n            </div>\n            <div :class=\"[prefixCls + '-fixed']\" :style=\"fixedTableStyle\" v-if=\"isLeftFixed\">\n                <div :class=\"fixedHeaderClasses\" v-if=\"showHeader\">\n                    <table-head\n                        fixed=\"left\"\n                        :prefix-cls=\"prefixCls\"\n                        :styleObject=\"fixedTableStyle\"\n                        :columns=\"leftFixedColumns\"\n                        :column-rows=\"columnRows\"\n                        :fixed-column-rows=\"leftFixedColumnRows\"\n                        :obj-data=\"objData\"\n                        :columns-width=\"columnsWidth\"\n                        :data=\"rebuildData\"></table-head>\n                </div>\n                <div :class=\"[prefixCls + '-fixed-body']\" :style=\"fixedBodyStyle\" ref=\"fixedBody\" @mousewheel=\"handleFixedMousewheel\" @DOMMouseScroll=\"handleFixedMousewheel\">\n                    <table-body\n                        fixed=\"left\"\n                        :draggable=\"draggable\"\n                        :prefix-cls=\"prefixCls\"\n                        :styleObject=\"fixedTableStyle\"\n                        :columns=\"leftFixedColumns\"\n                        :data=\"rebuildData\"\n                        :row-key=\"rowKey\"\n                        :columns-width=\"columnsWidth\"\n                        :obj-data=\"objData\"></table-body>\n                </div>\n                <table-summary\n                    v-if=\"showSummary && (data && data.length)\"\n                    fixed=\"left\"\n                    :prefix-cls=\"prefixCls\"\n                    :styleObject=\"fixedTableStyle\"\n                    :columns=\"leftFixedColumns\"\n                    :data=\"summaryData\"\n                    :columns-width=\"columnsWidth\"\n                    :style=\"{ 'margin-top': showHorizontalScrollBar ? scrollBarWidth + 'px' : 0 }\"\n                />\n            </div>\n            <div :class=\"[prefixCls + '-fixed-right']\" :style=\"fixedRightTableStyle\" v-if=\"isRightFixed\">\n                <div :class=\"fixedHeaderClasses\" v-if=\"showHeader\">\n                    <table-head\n                        fixed=\"right\"\n                        :prefix-cls=\"prefixCls\"\n                        :styleObject=\"fixedRightTableStyle\"\n                        :columns=\"rightFixedColumns\"\n                        :column-rows=\"columnRows\"\n                        :fixed-column-rows=\"rightFixedColumnRows\"\n                        :obj-data=\"objData\"\n                        :columns-width=\"columnsWidth\"\n                        :data=\"rebuildData\"></table-head>\n                </div>\n                <div :class=\"[prefixCls + '-fixed-body']\" :style=\"fixedBodyStyle\" ref=\"fixedRightBody\" @mousewheel=\"handleFixedMousewheel\" @DOMMouseScroll=\"handleFixedMousewheel\">\n                    <table-body\n                        fixed=\"right\"\n                        :draggable=\"draggable\"\n                        :prefix-cls=\"prefixCls\"\n                        :styleObject=\"fixedRightTableStyle\"\n                        :columns=\"rightFixedColumns\"\n                        :data=\"rebuildData\"\n                        :row-key=\"rowKey\"\n                        :columns-width=\"columnsWidth\"\n                        :obj-data=\"objData\"></table-body>\n                </div>\n                <table-summary\n                    v-if=\"showSummary && (data && data.length)\"\n                    fixed=\"right\"\n                    :prefix-cls=\"prefixCls\"\n                    :styleObject=\"fixedRightTableStyle\"\n                    :columns=\"rightFixedColumns\"\n                    :data=\"summaryData\"\n                    :columns-width=\"columnsWidth\"\n                    :style=\"{ 'margin-top': showHorizontalScrollBar ? scrollBarWidth + 'px' : 0 }\"\n                />\n            </div>\n            <div :class=\"[prefixCls + '-fixed-right-header']\" :style=\"fixedRightHeaderStyle\" v-if=\"isRightFixed\"></div>\n            <div :class=\"[prefixCls + '-footer']\" v-if=\"showSlotFooter\" ref=\"footer\"><slot name=\"footer\"></slot></div>\n        </div>\n        <div class=\"ivu-table-resize-line\" v-show=\"showResizeLine\" ref=\"resizeLine\"></div>\n        <div class=\"ivu-table-context-menu\" :style=\"contextMenuStyles\" v-if=\"showContextMenu\">\n            <Dropdown trigger=\"custom\" :visible=\"contextMenuVisible\" transfer @on-clickoutside=\"handleClickContextMenuOutside\">\n                <DropdownMenu slot=\"list\">\n                    <slot name=\"contextMenu\"></slot>\n                </DropdownMenu>\n            </Dropdown>\n        </div>\n        <Spin fix size=\"large\" v-if=\"loading\">\n            <slot name=\"loading\"></slot>\n        </Spin>\n    </div>\n</template>\n<script>\n    import tableHead from './table-head.vue';\n    import tableBody from './table-body.vue';\n    import tableSummary from './summary.vue';\n    import Spin from '../spin/spin.vue';\n    import { oneOf, getStyle, deepCopy, getScrollBarSize } from '../../utils/assist';\n    import { on, off } from '../../utils/dom';\n    import Csv from '../../utils/csv';\n    import ExportCsv from './export-csv';\n    import Locale from '../../mixins/locale';\n    import elementResizeDetectorMaker from 'element-resize-detector';\n    import { getAllColumns, convertToRows, convertColumnOrder, getRandomStr } from './util';\n\n    const prefixCls = 'ivu-table';\n\n    let rowKey = 1;\n    let columnKey = 1;\n\n    export default {\n        name: 'Table',\n        mixins: [ Locale ],\n        components: { tableHead, tableBody, tableSummary, Spin },\n        provide () {\n            return {\n                tableRoot: this\n            };\n        },\n        props: {\n            data: {\n                type: Array,\n                default () {\n                    return [];\n                }\n            },\n            columns: {\n                type: Array,\n                default () {\n                    return [];\n                }\n            },\n            size: {\n                validator (value) {\n                    return oneOf(value, ['small', 'large', 'default']);\n                },\n                default () {\n                    return !this.$IVIEW || this.$IVIEW.size === '' ? 'default' : this.$IVIEW.size;\n                }\n            },\n            width: {\n                type: [Number, String]\n            },\n            height: {\n                type: [Number, String]\n            },\n            // 3.4.0\n            maxHeight: {\n                type: [Number, String]\n            },\n            stripe: {\n                type: Boolean,\n                default: false\n            },\n            border: {\n                type: Boolean,\n                default: false\n            },\n            showHeader: {\n                type: Boolean,\n                default: true\n            },\n            highlightRow: {\n                type: Boolean,\n                default: false\n            },\n            rowClassName: {\n                type: Function,\n                default () {\n                    return '';\n                }\n            },\n            context: {\n                type: Object\n            },\n            noDataText: {\n                type: String\n            },\n            noFilteredDataText: {\n                type: String\n            },\n            disabledHover: {\n                type: Boolean\n            },\n            loading: {\n                type: Boolean,\n                default: false\n            },\n            draggable: {\n                type: Boolean,\n                default: false\n            },\n            tooltipTheme: {\n                validator (value) {\n                    return oneOf(value, ['dark', 'light']);\n                },\n                default: 'dark'\n            },\n            // #5380 :key  index\n            // 4.1  String\n            rowKey: {\n                type: [Boolean, String],\n                default: false\n            },\n            // 4.0.0\n            spanMethod: {\n                type: Function\n            },\n            // 4.0.0\n            showSummary: {\n                type: Boolean,\n                default: false\n            },\n            // 4.0.0\n            summaryMethod: {\n                type: Function\n            },\n            // 4.0.0\n            sumText: {\n                type: String\n            },\n            // 4.1.0\n            indentSize: {\n                type: Number,\n                default: 16\n            },\n            // 4.1.0\n            loadData: {\n                type: Function\n            },\n            // 4.1.0\n            contextMenu: {\n                type: Boolean,\n                default: false\n            },\n            // 4.2.0\n            showContextMenu: {\n                type: Boolean,\n                default: false\n            }\n        },\n        data () {\n            const colsWithId = this.makeColumnsId(this.columns);\n            return {\n                ready: false,\n                tableWidth: 0,\n                columnsWidth: {},\n                prefixCls: prefixCls,\n                compiledUids: [],\n                objData: this.makeObjData(),     // checkbox or highlight-row\n                rebuildData: [],    // for sort or filter\n                cloneColumns: this.makeColumns(colsWithId),\n                columnRows: this.makeColumnRows(false, colsWithId),\n                leftFixedColumnRows: this.makeColumnRows('left', colsWithId),\n                rightFixedColumnRows: this.makeColumnRows('right', colsWithId),\n                allColumns: getAllColumns(colsWithId),  // for multiple table-head, get columns that have no children\n                showSlotHeader: true,\n                showSlotFooter: true,\n                bodyHeight: 0,\n                scrollBarWidth: getScrollBarSize(),\n                currentContext: this.context,\n                cloneData: deepCopy(this.data),    // when Cell has a button to delete row data, clickCurrentRow will throw an error, so clone a data\n                showVerticalScrollBar:false,\n                showHorizontalScrollBar:false,\n                headerWidth:0,\n                headerHeight:0,\n                showResizeLine: false,\n                contextMenuVisible: false,\n                contextMenuStyles: {\n                    top: 0,\n                    left: 0\n                }\n            };\n        },\n        computed: {\n            localeNoDataText () {\n                if (this.noDataText === undefined) {\n                    return this.t('i.table.noDataText');\n                } else {\n                    return this.noDataText;\n                }\n            },\n            localeNoFilteredDataText () {\n                if (this.noFilteredDataText === undefined) {\n                    return this.t('i.table.noFilteredDataText');\n                } else {\n                    return this.noFilteredDataText;\n                }\n            },\n            localeSumText () {\n                if (this.sumText === undefined) {\n                    return this.t('i.table.sumText');\n                } else {\n                    return this.sumText;\n                }\n            },\n            wrapClasses () {\n                return [\n                    `${prefixCls}-wrapper`,\n                    {\n                        [`${prefixCls}-hide`]: !this.ready,\n                        [`${prefixCls}-with-header`]: this.showSlotHeader,\n                        [`${prefixCls}-with-footer`]: this.showSlotFooter,\n                        [`${prefixCls}-with-summary`]: this.showSummary,\n                        [`${prefixCls}-wrapper-with-border`]: this.border\n                    }\n                ];\n            },\n            classes () {\n                return [\n                    `${prefixCls}`,\n                    {\n                        [`${prefixCls}-${this.size}`]: !!this.size,\n                        [`${prefixCls}-border`]: this.border,\n                        [`${prefixCls}-stripe`]: this.stripe,\n                        [`${prefixCls}-with-fixed-top`]: !!this.height\n                    }\n                ];\n            },\n            fixedHeaderClasses () {\n                return [\n                    `${prefixCls}-fixed-header`,\n                    {\n                        [`${prefixCls}-fixed-header-with-empty`]: !this.rebuildData.length\n                    }\n                ];\n            },\n            styles () {\n                let style = {};\n                let summaryHeight = 0;\n                if (this.showSummary) {\n                    if (this.size === 'small') summaryHeight = 40;\n                    else if (this.size === 'large') summaryHeight = 60;\n                    else summaryHeight = 48;\n                }\n                if (this.height) {\n                    let height = parseInt(this.height) + summaryHeight;\n                    style.height = `${height}px`;\n                }\n                if (this.maxHeight) {\n                    const maxHeight = parseInt(this.maxHeight) + summaryHeight;\n                    style.maxHeight = `${maxHeight}px`;\n                }\n                if (this.width) style.width = `${this.width}px`;\n                return style;\n            },\n            tableStyle () {\n                let style = {};\n                if (this.tableWidth !== 0) {\n                    let width = '';\n                    if (this.bodyHeight === 0) {\n                        width = this.tableWidth;\n                    } else {\n                        width = this.tableWidth - (this.showVerticalScrollBar?this.scrollBarWidth:0);\n                    }\n//                    const width = this.bodyHeight === 0 ? this.tableWidth : this.tableWidth - this.scrollBarWidth;\n                    style.width = `${width}px`;\n                }\n                return style;\n            },\n            tableHeaderStyle () {\n                let style = {};\n                if (this.tableWidth !== 0) {\n                    let width = '';\n                    width = this.tableWidth;\n                    style.width = `${width}px`;\n                }\n                return style;\n            },\n            fixedTableStyle () {\n                let style = {};\n                let width = 0;\n                this.leftFixedColumns.forEach((col) => {\n                    if (col.fixed && col.fixed === 'left') width += col._width;\n                });\n                style.width = `${width}px`;\n                return style;\n            },\n            fixedRightTableStyle () {\n                let style = {};\n                let width = 0;\n                this.rightFixedColumns.forEach((col) => {\n                    if (col.fixed && col.fixed === 'right') width += col._width;\n                });\n                //width += this.scrollBarWidth;\n                style.width = `${width}px`;\n                style.right = `${this.showVerticalScrollBar?this.scrollBarWidth:0}px`;\n                return style;\n            },\n            fixedRightHeaderStyle () {\n                let style = {};\n                let width = 0;\n                let height = this.headerHeight+1;\n                if(this.showVerticalScrollBar){\n                    width = this.scrollBarWidth;\n                }\n                style.width = `${width}px`;\n                style.height = `${height}px`;\n                return style;\n            },\n            bodyStyle () {\n                let style = {};\n                if (this.bodyHeight !== 0) {\n                    const height = this.bodyHeight;\n                    if (this.height) {\n                        style.height = `${height}px`;\n                    } else if (this.maxHeight) {\n                        style.maxHeight = `${height}px`;\n                    }\n                }\n                return style;\n            },\n            fixedBodyStyle () {\n                let style = {};\n                if (this.bodyHeight !== 0) {\n                    let height = this.bodyHeight - (this.showHorizontalScrollBar?this.scrollBarWidth:0);\n                    style.height = this.showHorizontalScrollBar ? `${height}px` : `${height - 1}px`;\n                }\n                return style;\n            },\n            leftFixedColumns () {\n                return convertColumnOrder(this.cloneColumns, 'left');\n            },\n            rightFixedColumns () {\n                return convertColumnOrder(this.cloneColumns, 'right');\n            },\n            isLeftFixed () {\n                return this.columns.some(col => col.fixed && col.fixed === 'left');\n            },\n            isRightFixed () {\n                return this.columns.some(col => col.fixed && col.fixed === 'right');\n            },\n            // for summary data\n            summaryData () {\n                if (!this.showSummary) return {};\n\n                let sums = {};\n                if (this.summaryMethod) {\n                    sums = this.summaryMethod({ columns: this.cloneColumns, data: this.rebuildData });\n                } else {\n                    this.cloneColumns.forEach((column, index) => {\n                        const key = column.key;\n                        if (index === 0) {\n                            sums[key] = {\n                                key: column.key,\n                                value: this.localeSumText\n                            };\n                            return;\n                        }\n                        const values = this.rebuildData.map(item => Number(item[column.key]));\n                        const precisions = [];\n                        let notNumber = true;\n                        values.forEach(value => {\n                            if (!isNaN(value)) {\n                                notNumber = false;\n                                let decimal = ('' + value).split('.')[1];\n                                precisions.push(decimal ? decimal.length : 0);\n                            }\n                        });\n                        const precision = Math.max.apply(null, precisions);\n                        if (!notNumber) {\n                            const currentValue = values.reduce((prev, curr) => {\n                                const value = Number(curr);\n                                if (!isNaN(value)) {\n                                    return parseFloat((prev + curr).toFixed(Math.min(precision, 20)));\n                                } else {\n                                    return prev;\n                                }\n                            }, 0);\n                            sums[key] = {\n                                key: column.key,\n                                value: currentValue\n                            };\n                        } else {\n                            sums[key] = {\n                                key: column.key,\n                                value: ''\n                            };\n                        }\n                    });\n                }\n\n                return sums;\n            }\n        },\n        methods: {\n            rowClsName (index) {\n                return this.rowClassName(this.data[index], index);\n            },\n            handleResize () {\n                    //let tableWidth = parseInt(getStyle(this.$el, 'width')) - 1;\n                let tableWidth = this.$el.offsetWidth - 1;\n                let columnsWidth = {};\n                let sumMinWidth = 0;\n                let hasWidthColumns = [];\n                let noWidthColumns = [];\n                let maxWidthColumns = [];\n                let noMaxWidthColumns = [];\n                this.cloneColumns.forEach((col) => {\n                    if (col.width) {\n                        hasWidthColumns.push(col);\n                    }\n                    else{\n                        noWidthColumns.push(col);\n                        if (col.minWidth) {\n                            sumMinWidth += col.minWidth;\n                        }\n                        if (col.maxWidth) {\n                            maxWidthColumns.push(col);\n                        }\n                        else {\n                            noMaxWidthColumns.push(col);\n                        }\n                    }\n                    col._width = null;\n                });\n\n\n                let unUsableWidth = hasWidthColumns.map(cell => cell.width).reduce((a, b) => a + b, 0);\n                let usableWidth = tableWidth - unUsableWidth - sumMinWidth - (this.showVerticalScrollBar?this.scrollBarWidth:0) - 1;\n                let usableLength = noWidthColumns.length;\n                let columnWidth = 0;\n                if(usableWidth > 0 && usableLength > 0){\n                    columnWidth = parseInt(usableWidth / usableLength);\n                }\n\n\n                for (let i = 0; i < this.cloneColumns.length; i++) {\n                    const column = this.cloneColumns[i];\n                    let width = columnWidth + (column.minWidth?column.minWidth:0);\n                    if(column.width){\n                        width = column.width;\n                    }\n                    else{\n                        if (column._width) {\n                            width = column._width;\n                        }\n                        else {\n                            if (column.minWidth > width){\n                                width = column.minWidth;\n                            }\n                            else if (column.maxWidth < width){\n                                width = column.maxWidth;\n                            }\n\n                            if (usableWidth>0) {\n                                usableWidth -= width - (column.minWidth?column.minWidth:0);\n                                usableLength--;\n                                if (usableLength > 0) {\n                                    columnWidth = parseInt(usableWidth / usableLength);\n                                }\n                                else {\n                                    columnWidth = 0;\n                                }\n                            }\n                            else{\n                                columnWidth = 0;\n                            }\n                        }\n                    }\n\n                    column._width = width;\n\n                    columnsWidth[column._index] = {\n                        width: width\n                    };\n\n                }\n                if(usableWidth>0) {\n                    usableLength = noMaxWidthColumns.length;\n                    columnWidth = parseInt(usableWidth / usableLength);\n                    for (let i = 0; i < noMaxWidthColumns.length; i++) {\n                        const column = noMaxWidthColumns[i];\n                        let width = column._width + columnWidth;\n                        if (usableLength > 1) {\n                            usableLength--;\n                            usableWidth -= columnWidth;\n                            columnWidth = parseInt(usableWidth / usableLength);\n                        }\n                        else {\n                            columnWidth = 0;\n                        }\n\n                        column._width = width;\n\n                        columnsWidth[column._index] = {\n                            width: width\n                        };\n\n                    }\n                }\n\n                this.tableWidth = this.cloneColumns.map(cell => cell._width).reduce((a, b) => a + b, 0) + (this.showVerticalScrollBar?this.scrollBarWidth:0) + 1;\n                this.columnsWidth = columnsWidth;\n                this.fixedHeader();\n            },\n            handleMouseIn (_index, rowKey) {\n                if (this.disabledHover) return;\n                const objData = rowKey ? this.getDataByRowKey(rowKey) : this.objData[_index];\n                if (objData._isHover) return;\n                objData._isHover = true;\n            },\n            handleMouseOut (_index, rowKey) {\n                if (this.disabledHover) return;\n                const objData = rowKey ? this.getDataByRowKey(rowKey) : this.objData[_index];\n                objData._isHover = false;\n            },\n            //  highlightCurrentRow  clearCurrentRow\n            handleCurrentRow (type, _index, rowKey) {\n                const objData = rowKey ? this.getDataByRowKey(rowKey) : this.objData[_index];\n\n                let oldData = null;\n                let oldIndex = -1;\n\n                for (let i in this.objData) {\n                    if (this.objData[i]._isHighlight) {\n                        oldIndex = parseInt(i);\n                        this.objData[i]._isHighlight = false;\n                        break;\n                    } else if (this.objData[i].children && this.objData[i].children.length) {\n                        const resetData = this.handleResetChildrenRow(this.objData[i]);\n                        if (resetData) oldData = JSON.parse(JSON.stringify(resetData));\n                    }\n                }\n                if (type === 'highlight') objData._isHighlight = true;\n                if (oldIndex >= 0) {\n                    oldData = JSON.parse(JSON.stringify(this.cloneData[oldIndex]));\n                }\n                const newData = type === 'highlight' ? rowKey ? JSON.parse(JSON.stringify(this.getBaseDataByRowKey(rowKey))) : JSON.parse(JSON.stringify(this.cloneData[_index])) : null;\n                this.$emit('on-current-change', newData, oldData);\n            },\n            handleResetChildrenRow (objData) {\n                let data = null;\n                if (objData.children && objData.children.length) {\n                    for (let i = 0; i < objData.children.length; i++) {\n                        const item = objData.children[i];\n                        if (item._isHighlight) {\n                            item._isHighlight = false;\n                            data = item;\n                            break;\n                        } else if (item.children && item.children.length) {\n                            data = this.handleResetChildrenRow(item);\n                        }\n                    }\n                }\n                return data;\n            },\n            highlightCurrentRow (_index, rowKey) {\n                const objData = rowKey ? this.getDataByRowKey(rowKey) : this.objData[_index];\n                if (!this.highlightRow || objData._isHighlight) return;\n                this.handleCurrentRow('highlight', _index, rowKey);\n            },\n            clearCurrentRow () {\n                if (!this.highlightRow) return;\n                this.handleCurrentRow('clear');\n            },\n            clickCurrentRow (_index, rowKey) {\n                this.highlightCurrentRow (_index, rowKey);\n                if (rowKey) {\n                    this.$emit('on-row-click', JSON.parse(JSON.stringify(this.getBaseDataByRowKey(rowKey))));\n                } else {\n                    this.$emit('on-row-click', JSON.parse(JSON.stringify(this.cloneData[_index])), _index);\n                }\n            },\n            dblclickCurrentRow (_index, rowKey) {\n                this.highlightCurrentRow (_index, rowKey);\n                if (rowKey) {\n                    this.$emit('on-row-dblclick', JSON.parse(JSON.stringify(this.getBaseDataByRowKey(rowKey))));\n                } else {\n                    this.$emit('on-row-dblclick', JSON.parse(JSON.stringify(this.cloneData[_index])), _index);\n                }\n            },\n            contextmenuCurrentRow (_index, rowKey, event) {\n                const $TableWrap = this.$refs.tableWrap;\n                const TableBounding = $TableWrap.getBoundingClientRect();\n                const position = {\n                    left: `${event.clientX - TableBounding.left}px`,\n                    top: `${event.clientY - TableBounding.top}px`\n                };\n                this.contextMenuStyles = position;\n                this.contextMenuVisible = true;\n                if (rowKey) {\n                    this.$emit('on-contextmenu', JSON.parse(JSON.stringify(this.getBaseDataByRowKey(rowKey))), event, position);\n                } else {\n                    this.$emit('on-contextmenu', JSON.parse(JSON.stringify(this.cloneData[_index])), event, position);\n                }\n            },\n            getSelection () {\n                // \n                let selectionIndexes = [];\n                let selectionRowKeys = [];\n                for (let i in this.objData) {\n                    const objData = this.objData[i];\n                    if (objData._isChecked) selectionIndexes.push(parseInt(i));\n                    if (objData.children && objData.children.length) {\n                        selectionRowKeys = selectionRowKeys.concat(this.getSelectionChildrenRowKeys(objData, selectionRowKeys));\n                    }\n                }\n\n                //  RowKeys\n                selectionRowKeys = [...new Set(selectionRowKeys)];\n\n                let selection = [];\n\n                this.data.forEach((item, index) => {\n                    if (selectionIndexes.indexOf(index) > -1) {\n                        selection = selection.concat(item);\n                    }\n                    if (item.children && item.children.length && selectionRowKeys.length) {\n                        selection = selection.concat(this.getSelectionChildren(item, selection, selectionRowKeys));\n                    }\n                });\n\n\n                selection = [...new Set(selection)];\n                return JSON.parse(JSON.stringify(selection));\n            },\n            getSelectionChildrenRowKeys (objData, selectionRowKeys) {\n                if (objData.children && objData.children.length) {\n                    objData.children.forEach(item => {\n                        if (item._isChecked) selectionRowKeys.push(item._rowKey);\n                        if (item.children && item.children.length) {\n                            selectionRowKeys = selectionRowKeys.concat(this.getSelectionChildrenRowKeys(item, selectionRowKeys));\n                        }\n                    });\n                }\n                return selectionRowKeys;\n            },\n            getSelectionChildren (data, selection, selectionRowKeys) {\n                if (data.children && data.children.length) {\n                    data.children.forEach(item => {\n                        if (selectionRowKeys.indexOf(item[this.rowKey]) > -1) {\n                            selection = selection.concat(item);\n                        }\n                        if (item.children && item.children.length) {\n                            selection = selection.concat(this.getSelectionChildren(item, selection, selectionRowKeys));\n                        }\n                    });\n                }\n                return selection;\n            },\n            toggleSelect (_index, rowKey) {\n                let data = {};\n\n                if (rowKey) {\n                    data = this.getDataByRowKey(rowKey);\n                } else {\n                    for (let i in this.objData) {\n                        if (parseInt(i) === _index) {\n                            data = this.objData[i];\n                            break;\n                        }\n                    }\n                }\n                const status = !data._isChecked;\n\n                data._isChecked = status;\n                const selection = this.getSelection();\n                const selectedData = rowKey ? this.getBaseDataByRowKey(rowKey, this.data) : this.data[_index];\n                this.$emit(status ? 'on-select' : 'on-select-cancel', selection, JSON.parse(JSON.stringify(selectedData)));\n                this.$emit('on-selection-change', selection);\n            },\n            toggleExpand (_index) {\n                let data = {};\n\n                for (let i in this.objData) {\n                    if (parseInt(i) === _index) {\n                        data = this.objData[i];\n                        break;\n                    }\n                }\n                const status = !data._isExpanded;\n                this.objData[_index]._isExpanded = status;\n                this.$emit('on-expand', JSON.parse(JSON.stringify(this.cloneData[_index])), status);\n\n                if(this.height || this.maxHeight){\n                    this.$nextTick(()=>this.fixedBody());\n                }\n            },\n            toggleTree (rowKey) {\n                const data = this.getDataByRowKey(rowKey);\n                // async loading\n                if ('_loading' in data && data._loading) return;\n                if ('_loading' in data && !data._loading && data.children.length === 0) {\n                    const sourceData = this.getBaseDataByRowKey(rowKey, this.data);\n                    this.$set(sourceData, '_loading', true);\n                    this.loadData(sourceData, children => {\n                        this.$set(sourceData, '_loading', false);\n                        if (children.length) {\n                            this.$set(sourceData, 'children', children);\n                            this.$nextTick(() => {\n                                const newData = this.getDataByRowKey(rowKey);\n                                newData._isShowChildren = !newData._isShowChildren;\n                                this.updateDataStatus(rowKey, '_showChildren', newData._isShowChildren);\n                            });\n                        }\n                    });\n                    return;\n                }\n\n                data._isShowChildren = !data._isShowChildren;\n                this.updateDataStatus(rowKey, '_showChildren', data._isShowChildren);\n            },\n            /**\n             * @description  _isShowChildren  data  _showChildren  data \n             * @param rowKey rowKey\n             * @param key \n             * @param value \n             * */\n            // todo \n            updateDataStatus (rowKey, key, value) {\n                const data = this.getBaseDataByRowKey(rowKey, this.data);\n                this.$set(data, key, value);\n            },\n            getDataByRowKey (rowKey, objData = this.objData) {\n                let data = null;\n                for (let i in objData) {\n                    const thisData = objData[i];\n                    if (thisData._rowKey === rowKey) {\n                        data = thisData;\n                        break;\n                    } else if (thisData.children && thisData.children.length) {\n                        data = this.getChildrenByRowKey(rowKey, thisData);\n                        if (data) {\n                            break;\n                        }\n                    }\n                }\n                return data;\n            },\n            getChildrenByRowKey (rowKey, objData) {\n                let data = null;\n                if (objData.children && objData.children.length) {\n                    for (let i = 0; i < objData.children.length; i++) {\n                        const item = objData.children[i];\n                        if (item._rowKey === rowKey) {\n                            data = item;\n                            break;\n                        } else if (item.children && item.children.length) {\n                            data = this.getChildrenByRowKey(rowKey, item);\n                            if (data) {\n                                break;\n                            }\n                        }\n                    }\n                }\n                return data;\n            },\n            getBaseDataByRowKey (rowKey, sourceData = this.cloneData) {\n                let data = null;\n                for (let i = 0; i < sourceData.length; i++) {\n                    const thisData = sourceData[i];\n                    if (thisData[this.rowKey] === rowKey) {\n                        data = thisData;\n                        break;\n                    } else if (thisData.children && thisData.children.length) {\n                        data = this.getChildrenDataByRowKey(rowKey, thisData);\n                        if (data && data[this.rowKey] === rowKey) return data;\n                    }\n                }\n                return data;\n            },\n            getChildrenDataByRowKey (rowKey, cloneData) {\n                let data = null;\n                if (cloneData.children && cloneData.children.length) {\n                    for (let i = 0; i < cloneData.children.length; i++) {\n                        const item = cloneData.children[i];\n                        if (item[this.rowKey] === rowKey) {\n                            data = item;\n                            break;\n                        } else if (item.children && item.children.length) {\n                            data = this.getChildrenDataByRowKey(rowKey, item);\n                            if (data) {\n                                break;\n                            }\n                        }\n                    }\n                }\n                return data;\n            },\n            selectAll (status) {\n                // this.rebuildData.forEach((data) => {\n                //     if(this.objData[data._index]._isDisabled){\n                //         this.objData[data._index]._isChecked = false;\n                //     }else{\n                //         this.objData[data._index]._isChecked = status;\n                //     }\n\n                // });\n                for (const data of this.rebuildData) {\n                    const objData = this.objData[data._index];\n                    if (!objData._isDisabled) {\n                        objData._isChecked = status;\n                    }\n                    if (data.children && data.children.length) {\n                        this.selectAllChildren(objData, status);\n                    }\n                }\n                const selection = this.getSelection();\n                if (status) {\n                    this.$emit('on-select-all', selection);\n                } else {\n                    this.$emit('on-select-all-cancel', selection);\n                }\n                this.$emit('on-selection-change', selection);\n            },\n            selectAllChildren (data, status) {\n                if (data.children && data.children.length) {\n                    data.children.map(item => {\n                        if (!item._isDisabled) {\n                            item._isChecked = status;\n                        }\n                        if (item.children && item.children.length) {\n                            this.selectAllChildren(item, status);\n                        }\n                    });\n                }\n            },\n            fixedHeader () {\n                if (this.height || this.maxHeight) {\n                    this.$nextTick(() => {\n                        const titleHeight = parseInt(getStyle(this.$refs.title, 'height')) || 0;\n                        const headerHeight = parseInt(getStyle(this.$refs.header, 'height')) || 0;\n                        const footerHeight = parseInt(getStyle(this.$refs.footer, 'height')) || 0;\n                        if (this.height) {\n                            this.bodyHeight = this.height - titleHeight - headerHeight - footerHeight;\n                        } else if (this.maxHeight) {\n                            this.bodyHeight = this.maxHeight - titleHeight - headerHeight - footerHeight;\n                        }\n                        this.$nextTick(()=>this.fixedBody());\n                    });\n                } else {\n                    this.bodyHeight = 0;\n                    this.$nextTick(()=>this.fixedBody());\n                }\n            },\n            fixedBody (){\n                if (this.$refs.header) {\n                    this.headerWidth = this.$refs.header.children[0].offsetWidth;\n                    this.headerHeight = this.$refs.header.children[0].offsetHeight;\n                    //this.showHorizontalScrollBar = this.headerWidth>this.$refs.header.offsetWidth;\n                }\n\n                if (!this.$refs.tbody || !this.data || this.data.length === 0) {\n                    this.showVerticalScrollBar = false;\n                }\n                else{\n                    let bodyContentEl = this.$refs.tbody.$el;\n                    let bodyEl = bodyContentEl.parentElement;\n                    let bodyContentHeight = bodyContentEl.offsetHeight;\n                    let bodyHeight = bodyEl.offsetHeight;\n\n                    this.showHorizontalScrollBar = bodyEl.offsetWidth < bodyContentEl.offsetWidth + (this.showVerticalScrollBar?this.scrollBarWidth:0);\n                    this.showVerticalScrollBar = this.bodyHeight? bodyHeight - (this.showHorizontalScrollBar?this.scrollBarWidth:0) < bodyContentHeight : false;\n\n                    if(this.showVerticalScrollBar){\n                        bodyEl.classList.add(this.prefixCls +'-overflowY');\n                    }else{\n                        bodyEl.classList.remove(this.prefixCls +'-overflowY');\n                    }\n                    if(this.showHorizontalScrollBar){\n                        bodyEl.classList.add(this.prefixCls +'-overflowX');\n                    }else{\n                        bodyEl.classList.remove(this.prefixCls +'-overflowX');\n                    }\n                }\n            },\n\n            hideColumnFilter () {\n                this.cloneColumns.forEach((col) => col._filterVisible = false);\n            },\n            handleBodyScroll (event) {\n                if (this.showHeader) this.$refs.header.scrollLeft = event.target.scrollLeft;\n                if (this.isLeftFixed) this.$refs.fixedBody.scrollTop = event.target.scrollTop;\n                if (this.isRightFixed) this.$refs.fixedRightBody.scrollTop = event.target.scrollTop;\n                if (this.showSummary) this.$refs.summary.$el.scrollLeft = event.target.scrollLeft;\n                this.hideColumnFilter();\n            },\n            handleFixedMousewheel(event) {\n                let deltaY = event.deltaY;\n                if(!deltaY && event.detail){\n                    deltaY = event.detail * 40;\n                }\n                if(!deltaY && event.wheelDeltaY){\n                    deltaY = -event.wheelDeltaY;\n                }\n                if(!deltaY && event.wheelDelta){\n                    deltaY = -event.wheelDelta;\n                }\n                if(!deltaY) return;\n                const body = this.$refs.body;\n                const currentScrollTop = body.scrollTop;\n                if (deltaY < 0 && currentScrollTop !== 0) {\n                    event.preventDefault();\n                }\n                if (deltaY > 0 && body.scrollHeight - body.clientHeight > currentScrollTop) {\n                    event.preventDefault();\n                }\n                //body.scrollTop += deltaY;\n                let step = 0;\n                let timeId = setInterval(()=>{\n                    step += 5;\n                    if(deltaY>0){\n                        body.scrollTop += 2;\n                    }\n                    else{\n                        body.scrollTop -= 2;\n                    }\n                    if(step >= Math.abs(deltaY)){\n                        clearInterval(timeId);\n                    }\n                }, 5);\n            },\n            handleMouseWheel (event) {\n                const deltaX = event.deltaX;\n                const $body = this.$refs.body;\n\n                if (deltaX > 0) {\n                    $body.scrollLeft = $body.scrollLeft + 10;\n                } else {\n                    $body.scrollLeft = $body.scrollLeft - 10;\n                }\n            },\n            sortData (data, type, index) {\n                const key = this.cloneColumns[index].key;\n                data.sort((a, b) => {\n                    if (this.cloneColumns[index].sortMethod) {\n                        return this.cloneColumns[index].sortMethod(a[key], b[key], type);\n                    } else {\n                        if (type === 'asc') {\n                            return a[key] > b[key] ? 1 : -1;\n                        } else if (type === 'desc') {\n                            return a[key] < b[key] ? 1 : -1;\n                        }\n                    }\n                });\n                for (let i = 0; i < data.length; i++) {\n                    if (data[i].children && data[i].children.length) {\n                        data[i].children = this.sortData(data[i].children, type, index);\n                    }\n                }\n                return data;\n            },\n            handleSort (_index, type) {\n                const index = this.GetOriginalIndex(_index);\n                this.cloneColumns.forEach((col) => col._sortType = 'normal');\n\n                const key = this.cloneColumns[index].key;\n                if (this.cloneColumns[index].sortable !== 'custom') {    // custom is for remote sort\n                    if (type === 'normal') {\n                        this.rebuildData = this.makeDataWithFilter();\n                    } else {\n                        this.rebuildData = this.sortData(this.rebuildData, type, index);\n                    }\n                }\n                this.cloneColumns[index]._sortType = type;\n\n                this.$emit('on-sort-change', {\n                    column: JSON.parse(JSON.stringify(this.allColumns[this.cloneColumns[index]._index])),\n                    key: key,\n                    order: type\n                });\n            },\n            handleFilterHide (index) {    // clear checked that not filter now\n                if (!this.cloneColumns[index]._isFiltered) this.cloneColumns[index]._filterChecked = [];\n            },\n            filterData (data, column) {\n                return data.filter((row) => {\n                    //\n                    if (typeof column.filterRemote === 'function') return true;\n\n                    let status = !column._filterChecked.length;\n                    for (let i = 0; i < column._filterChecked.length; i++) {\n                        status = column.filterMethod(column._filterChecked[i], row);\n                        if (status) break;\n                    }\n                    return status;\n                });\n            },\n            filterOtherData (data, index) {\n                let column = this.cloneColumns[index];\n                if (typeof column.filterRemote === 'function') {\n                    column.filterRemote.call(this.$parent, column._filterChecked, column.key, column);\n                }\n\n                this.cloneColumns.forEach((col, colIndex) => {\n                    if (colIndex !== index) {\n                        data = this.filterData(data, col);\n                    }\n                });\n                return data;\n            },\n            handleFilter (index) {\n                const column = this.cloneColumns[index];\n                let filterData = this.makeDataWithSort();\n\n                // filter others first, after filter this column\n                filterData = this.filterOtherData(filterData, index);\n                this.rebuildData = this.filterData(filterData, column);\n\n                this.cloneColumns[index]._isFiltered = true;\n                this.cloneColumns[index]._filterVisible = false;\n                this.$emit('on-filter-change', column);\n            },\n            /**\n             * #2832\n             *  column \n             *  $parent  index  cloneColumns  index \n             * \n             *  index\n             * */\n            GetOriginalIndex (_index) {\n                return this.cloneColumns.findIndex(item => item._index === _index);\n            },\n            handleFilterSelect (_index, value) {\n                const index = this.GetOriginalIndex(_index);\n                this.cloneColumns[index]._filterChecked = [value];\n                this.handleFilter(index);\n            },\n            handleFilterReset (_index) {\n                const index = this.GetOriginalIndex(_index);\n                this.cloneColumns[index]._isFiltered = false;\n                this.cloneColumns[index]._filterVisible = false;\n                this.cloneColumns[index]._filterChecked = [];\n\n                let filterData = this.makeDataWithSort();\n                filterData = this.filterOtherData(filterData, index);\n                this.rebuildData = filterData;\n                this.$emit('on-filter-change', this.cloneColumns[index]);\n            },\n            makeData () {\n                let data = deepCopy(this.data);\n                data.forEach((row, index) => {\n                    row._index = index;\n                    row._rowKey = (typeof this.rowKey) === 'string' ? row[this.rowKey] : rowKey++;\n                    if (row.children && row.children.length) {\n                        row.children = this.makeChildrenData(row);\n                    }\n                });\n                return data;\n            },\n            makeChildrenData (data) {\n                if (data.children && data.children.length) {\n                    return data.children.map((row, index) => {\n                        const newRow = deepCopy(row);\n                        newRow._index = index;\n                        newRow._rowKey = (typeof this.rowKey) === 'string' ? newRow[this.rowKey] : rowKey++;\n                        if (newRow.children && newRow.children.length) {\n                            newRow.children = this.makeChildrenData(newRow);\n                        }\n                        return newRow;\n                    });\n                } else {\n                    return data;\n                }\n            },\n            makeDataWithSort () {\n                let data = this.makeData();\n                let sortType = 'normal';\n                let sortIndex = -1;\n                let isCustom = false;\n\n                for (let i = 0; i < this.cloneColumns.length; i++) {\n                    if (this.cloneColumns[i]._sortType !== 'normal') {\n                        sortType = this.cloneColumns[i]._sortType;\n                        sortIndex = i;\n                        isCustom = this.cloneColumns[i].sortable === 'custom';\n                        break;\n                    }\n                }\n                if (sortType !== 'normal' && !isCustom) data =  this.sortData(data, sortType, sortIndex);\n                return data;\n            },\n            makeDataWithFilter () {\n                let data = this.makeData();\n                this.cloneColumns.forEach(col => data = this.filterData(data, col));\n                return data;\n            },\n            makeDataWithSortAndFilter () {\n                let data = this.makeDataWithSort();\n                this.cloneColumns.forEach(col => data = this.filterData(data, col));\n                return data;\n            },\n            makeObjBaseData (row) {\n                const newRow = deepCopy(row);\n                if ((typeof this.rowKey) === 'string') {\n                    newRow._rowKey = newRow[this.rowKey];\n                }\n                newRow._isHover = false;\n                if (newRow._disabled) {\n                    newRow._isDisabled = newRow._disabled;\n                } else {\n                    newRow._isDisabled = false;\n                }\n                if (newRow._checked) {\n                    newRow._isChecked = newRow._checked;\n                } else {\n                    newRow._isChecked = false;\n                }\n                if (newRow._expanded) {\n                    newRow._isExpanded = newRow._expanded;\n                } else {\n                    newRow._isExpanded = false;\n                }\n                if (newRow._highlight) {\n                    newRow._isHighlight = newRow._highlight;\n                } else {\n                    newRow._isHighlight = false;\n                }\n                return newRow;\n            },\n            makeObjData () {\n                let data = {};\n                this.data.forEach((row, index) => {\n                    const newRow = this.makeObjBaseData(row);\n                    if (newRow.children && newRow.children.length) {\n                        if (newRow._showChildren) {\n                            newRow._isShowChildren = newRow._showChildren;\n                        } else {\n                            newRow._isShowChildren = false;\n                        }\n                        newRow.children = this.makeChildrenObjData(newRow);\n                    }\n                    // else if ('_loading' in newRow && newRow.children && newRow.children.length === 0) {\n                    //     newRow._isShowChildren = false;\n                    // }\n                    data[index] = newRow;\n                });\n                return data;\n            },\n            makeChildrenObjData (data) {\n                if (data.children && data.children.length) {\n                    return data.children.map(row => {\n                        const newRow = this.makeObjBaseData(row);\n                        if (newRow._showChildren) {\n                            newRow._isShowChildren = newRow._showChildren;\n                        } else {\n                            newRow._isShowChildren = false;\n                        }\n                        if (newRow.children && newRow.children.length) {\n                            newRow.children = this.makeChildrenObjData(newRow);\n                        }\n                        return newRow;\n                    });\n                } else {\n                    return data;\n                }\n            },\n            //  id\n            makeColumnsId (columns) {\n                return columns.map(item => {\n                    if ('children' in item) this.makeColumnsId(item.children);\n                    item.__id = getRandomStr(6);\n                    return item;\n                });\n            },\n            makeColumns (cols) {\n                //  data this.allColumns  undefined\n                let columns = deepCopy(getAllColumns(cols));\n                let left = [];\n                let right = [];\n                let center = [];\n\n                columns.forEach((column, index) => {\n                    column._index = index;\n                    column._columnKey = columnKey++;\n                    column.width = parseInt(column.width);\n                    column._width = column.width ? column.width : '';    // update in handleResize()\n                    column._sortType = 'normal';\n                    column._filterVisible = false;\n                    column._isFiltered = false;\n                    column._filterChecked = [];\n\n                    if ('filterMultiple' in column) {\n                        column._filterMultiple = column.filterMultiple;\n                    } else {\n                        column._filterMultiple = true;\n                    }\n                    if ('filteredValue' in column) {\n                        column._filterChecked = column.filteredValue;\n                        column._isFiltered = true;\n                    }\n\n                    if ('sortType' in column) {\n                        column._sortType = column.sortType;\n                    }\n\n                    if (column.fixed && column.fixed === 'left') {\n                        left.push(column);\n                    } else if (column.fixed && column.fixed === 'right') {\n                        right.push(column);\n                    } else {\n                        center.push(column);\n                    }\n                });\n                return left.concat(center).concat(right);\n            },\n            // create a multiple table-head\n            makeColumnRows (fixedType, cols) {\n                return convertToRows(cols, fixedType);\n            },\n            exportCsv (params) {\n                if (params.filename) {\n                    if (params.filename.indexOf('.csv') === -1) {\n                        params.filename += '.csv';\n                    }\n                } else {\n                    params.filename = 'table.csv';\n                }\n\n                let columns = [];\n                let datas = [];\n                if (params.columns && params.data) {\n                    columns = params.columns;\n                    datas = params.data;\n                } else {\n                    columns = this.allColumns;\n                    if (!('original' in params)) params.original = true;\n                    datas = params.original ? this.data : this.rebuildData;\n                }\n\n                let noHeader = false;\n                if ('noHeader' in params) noHeader = params.noHeader;\n\n                const data = Csv(columns, datas, params, noHeader);\n                if (params.callback) params.callback(data);\n                else ExportCsv.download(params.filename, data);\n            },\n            dragAndDrop(a,b) {\n                this.$emit('on-drag-drop', a,b);\n            },\n            handleClickContextMenuOutside (event) {\n                this.contextMenuVisible = false;\n            }\n        },\n        created () {\n            if (!this.context) this.currentContext = this.$parent;\n            this.showSlotHeader = this.$slots.header !== undefined;\n            this.showSlotFooter = this.$slots.footer !== undefined;\n            this.rebuildData = this.makeDataWithSortAndFilter();\n        },\n        mounted () {\n            this.handleResize();\n            this.$nextTick(() => this.ready = true);\n\n            on(window, 'resize', this.handleResize);\n            this.observer = elementResizeDetectorMaker();\n            this.observer.listenTo(this.$el, this.handleResize);\n\n            this.$on('on-visible-change', (val) => {\n                if (val) {\n                    this.$nextTick(() => {\n                        this.handleResize();\n                    });\n                }\n            });\n        },\n        beforeDestroy () {\n            off(window, 'resize', this.handleResize);\n            this.observer.removeListener(this.$el, this.handleResize);\n        },\n        watch: {\n            data: {\n                handler () {\n                    const oldDataLen = this.rebuildData.length;\n                    this.objData = this.makeObjData();\n                    this.rebuildData = this.makeDataWithSortAndFilter();\n                    this.handleResize();\n                    if (!oldDataLen) {\n                        this.fixedHeader();\n                    }\n                    // here will trigger before clickCurrentRow, so use async\n                    setTimeout(() => {\n                        this.cloneData = deepCopy(this.data);\n                    }, 0);\n                },\n                deep: true\n            },\n            columns: {\n                handler () {\n                    // todo \n                    const colsWithId = this.makeColumnsId(this.columns);\n                    this.allColumns = getAllColumns(colsWithId);\n                    this.cloneColumns = this.makeColumns(colsWithId);\n\n                    this.columnRows = this.makeColumnRows(false, colsWithId);\n                    this.leftFixedColumnRows = this.makeColumnRows('left', colsWithId);\n                    this.rightFixedColumnRows = this.makeColumnRows('right', colsWithId);\n                    this.rebuildData = this.makeDataWithSortAndFilter();\n                    this.handleResize();\n                },\n                deep: true\n            },\n            height () {\n                this.handleResize();\n            },\n            maxHeight () {\n                this.handleResize();\n            },\n            showHorizontalScrollBar () {\n                this.handleResize();\n            },\n            showVerticalScrollBar () {\n                this.handleResize();\n            }\n        }\n    };\n</script>\n"]}]}